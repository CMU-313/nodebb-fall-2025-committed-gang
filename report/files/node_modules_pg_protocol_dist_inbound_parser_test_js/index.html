<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/pg-protocol/dist/inbound-parser.test.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/pg-protocol/dist/inbound-parser.test.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.48</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">524</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">50.91</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.21</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { &quot;default&quot;: mod };
};
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
const test_buffers_1 = __importDefault(require(&quot;./testing/test-buffers&quot;));
const buffer_list_1 = __importDefault(require(&quot;./testing/buffer-list&quot;));
const _1 = require(&quot;.&quot;);
const assert_1 = __importDefault(require(&quot;assert&quot;));
const stream_1 = require(&quot;stream&quot;);
const authOkBuffer = test_buffers_1.default.authenticationOk();
const paramStatusBuffer = test_buffers_1.default.parameterStatus(&#039;client_encoding&#039;, &#039;UTF8&#039;);
const readyForQueryBuffer = test_buffers_1.default.readyForQuery();
const backendKeyDataBuffer = test_buffers_1.default.backendKeyData(1, 2);
const commandCompleteBuffer = test_buffers_1.default.commandComplete(&#039;SELECT 3&#039;);
const parseCompleteBuffer = test_buffers_1.default.parseComplete();
const bindCompleteBuffer = test_buffers_1.default.bindComplete();
const portalSuspendedBuffer = test_buffers_1.default.portalSuspended();
const row1 = {
    name: &#039;id&#039;,
    tableID: 1,
    attributeNumber: 2,
    dataTypeID: 3,
    dataTypeSize: 4,
    typeModifier: 5,
    formatCode: 0,
};
const oneRowDescBuff = test_buffers_1.default.rowDescription([row1]);
row1.name = &#039;bang&#039;;
const twoRowBuf = test_buffers_1.default.rowDescription([
    row1,
    {
        name: &#039;whoah&#039;,
        tableID: 10,
        attributeNumber: 11,
        dataTypeID: 12,
        dataTypeSize: 13,
        typeModifier: 14,
        formatCode: 0,
    },
]);
const rowWithBigOids = {
    name: &#039;bigoid&#039;,
    tableID: 3000000001,
    attributeNumber: 2,
    dataTypeID: 3000000003,
    dataTypeSize: 4,
    typeModifier: 5,
    formatCode: 0,
};
const bigOidDescBuff = test_buffers_1.default.rowDescription([rowWithBigOids]);
const emptyRowFieldBuf = test_buffers_1.default.dataRow([]);
const oneFieldBuf = test_buffers_1.default.dataRow([&#039;test&#039;]);
const expectedAuthenticationOkayMessage = {
    name: &#039;authenticationOk&#039;,
    length: 8,
};
const expectedParameterStatusMessage = {
    name: &#039;parameterStatus&#039;,
    parameterName: &#039;client_encoding&#039;,
    parameterValue: &#039;UTF8&#039;,
    length: 25,
};
const expectedBackendKeyDataMessage = {
    name: &#039;backendKeyData&#039;,
    processID: 1,
    secretKey: 2,
};
const expectedReadyForQueryMessage = {
    name: &#039;readyForQuery&#039;,
    length: 5,
    status: &#039;I&#039;,
};
const expectedCommandCompleteMessage = {
    name: &#039;commandComplete&#039;,
    length: 13,
    text: &#039;SELECT 3&#039;,
};
const emptyRowDescriptionBuffer = new buffer_list_1.default()
    .addInt16(0) // number of fields
    .join(true, &#039;T&#039;);
const expectedEmptyRowDescriptionMessage = {
    name: &#039;rowDescription&#039;,
    length: 6,
    fieldCount: 0,
    fields: [],
};
const expectedOneRowMessage = {
    name: &#039;rowDescription&#039;,
    length: 27,
    fieldCount: 1,
    fields: [
        {
            name: &#039;id&#039;,
            tableID: 1,
            columnID: 2,
            dataTypeID: 3,
            dataTypeSize: 4,
            dataTypeModifier: 5,
            format: &#039;text&#039;,
        },
    ],
};
const expectedTwoRowMessage = {
    name: &#039;rowDescription&#039;,
    length: 53,
    fieldCount: 2,
    fields: [
        {
            name: &#039;bang&#039;,
            tableID: 1,
            columnID: 2,
            dataTypeID: 3,
            dataTypeSize: 4,
            dataTypeModifier: 5,
            format: &#039;text&#039;,
        },
        {
            name: &#039;whoah&#039;,
            tableID: 10,
            columnID: 11,
            dataTypeID: 12,
            dataTypeSize: 13,
            dataTypeModifier: 14,
            format: &#039;text&#039;,
        },
    ],
};
const expectedBigOidMessage = {
    name: &#039;rowDescription&#039;,
    length: 31,
    fieldCount: 1,
    fields: [
        {
            name: &#039;bigoid&#039;,
            tableID: 3000000001,
            columnID: 2,
            dataTypeID: 3000000003,
            dataTypeSize: 4,
            dataTypeModifier: 5,
            format: &#039;text&#039;,
        },
    ],
};
const emptyParameterDescriptionBuffer = new buffer_list_1.default()
    .addInt16(0) // number of parameters
    .join(true, &#039;t&#039;);
const oneParameterDescBuf = test_buffers_1.default.parameterDescription([1111]);
const twoParameterDescBuf = test_buffers_1.default.parameterDescription([2222, 3333]);
const expectedEmptyParameterDescriptionMessage = {
    name: &#039;parameterDescription&#039;,
    length: 6,
    parameterCount: 0,
    dataTypeIDs: [],
};
const expectedOneParameterMessage = {
    name: &#039;parameterDescription&#039;,
    length: 10,
    parameterCount: 1,
    dataTypeIDs: [1111],
};
const expectedTwoParameterMessage = {
    name: &#039;parameterDescription&#039;,
    length: 14,
    parameterCount: 2,
    dataTypeIDs: [2222, 3333],
};
const testForMessage = function (buffer, expectedMessage) {
    it(&#039;receives and parses &#039; + expectedMessage.name, () =&gt; __awaiter(this, void 0, void 0, function* () {
        const messages = yield parseBuffers([buffer]);
        const [lastMessage] = messages;
        for (const key in expectedMessage) {
            assert_1.default.deepEqual(lastMessage[key], expectedMessage[key]);
        }
    }));
};
const plainPasswordBuffer = test_buffers_1.default.authenticationCleartextPassword();
const md5PasswordBuffer = test_buffers_1.default.authenticationMD5Password();
const SASLBuffer = test_buffers_1.default.authenticationSASL();
const SASLContinueBuffer = test_buffers_1.default.authenticationSASLContinue();
const SASLFinalBuffer = test_buffers_1.default.authenticationSASLFinal();
const expectedPlainPasswordMessage = {
    name: &#039;authenticationCleartextPassword&#039;,
};
const expectedMD5PasswordMessage = {
    name: &#039;authenticationMD5Password&#039;,
    salt: Buffer.from([1, 2, 3, 4]),
};
const expectedSASLMessage = {
    name: &#039;authenticationSASL&#039;,
    mechanisms: [&#039;SCRAM-SHA-256&#039;],
};
const expectedSASLContinueMessage = {
    name: &#039;authenticationSASLContinue&#039;,
    data: &#039;data&#039;,
};
const expectedSASLFinalMessage = {
    name: &#039;authenticationSASLFinal&#039;,
    data: &#039;data&#039;,
};
const notificationResponseBuffer = test_buffers_1.default.notification(4, &#039;hi&#039;, &#039;boom&#039;);
const expectedNotificationResponseMessage = {
    name: &#039;notification&#039;,
    processId: 4,
    channel: &#039;hi&#039;,
    payload: &#039;boom&#039;,
};
const parseBuffers = (buffers) =&gt; __awaiter(void 0, void 0, void 0, function* () {
    const stream = new stream_1.PassThrough();
    for (const buffer of buffers) {
        stream.write(buffer);
    }
    stream.end();
    const msgs = [];
    yield (0, _1.parse)(stream, (msg) =&gt; msgs.push(msg));
    return msgs;
});
describe(&#039;PgPacketStream&#039;, function () {
    testForMessage(authOkBuffer, expectedAuthenticationOkayMessage);
    testForMessage(plainPasswordBuffer, expectedPlainPasswordMessage);
    testForMessage(md5PasswordBuffer, expectedMD5PasswordMessage);
    testForMessage(SASLBuffer, expectedSASLMessage);
    testForMessage(SASLContinueBuffer, expectedSASLContinueMessage);
    // this exercises a found bug in the parser:
    // https://github.com/brianc/node-postgres/pull/2210#issuecomment-627626084
    // and adds a test which is deterministic, rather than relying on network packet chunking
    const extendedSASLContinueBuffer = Buffer.concat([SASLContinueBuffer, Buffer.from([1, 2, 3, 4])]);
    testForMessage(extendedSASLContinueBuffer, expectedSASLContinueMessage);
    testForMessage(SASLFinalBuffer, expectedSASLFinalMessage);
    // this exercises a found bug in the parser:
    // https://github.com/brianc/node-postgres/pull/2210#issuecomment-627626084
    // and adds a test which is deterministic, rather than relying on network packet chunking
    const extendedSASLFinalBuffer = Buffer.concat([SASLFinalBuffer, Buffer.from([1, 2, 4, 5])]);
    testForMessage(extendedSASLFinalBuffer, expectedSASLFinalMessage);
    testForMessage(paramStatusBuffer, expectedParameterStatusMessage);
    testForMessage(backendKeyDataBuffer, expectedBackendKeyDataMessage);
    testForMessage(readyForQueryBuffer, expectedReadyForQueryMessage);
    testForMessage(commandCompleteBuffer, expectedCommandCompleteMessage);
    testForMessage(notificationResponseBuffer, expectedNotificationResponseMessage);
    testForMessage(test_buffers_1.default.emptyQuery(), {
        name: &#039;emptyQuery&#039;,
        length: 4,
    });
    testForMessage(Buffer.from([0x6e, 0, 0, 0, 4]), {
        name: &#039;noData&#039;,
    });
    describe(&#039;rowDescription messages&#039;, function () {
        testForMessage(emptyRowDescriptionBuffer, expectedEmptyRowDescriptionMessage);
        testForMessage(oneRowDescBuff, expectedOneRowMessage);
        testForMessage(twoRowBuf, expectedTwoRowMessage);
        testForMessage(bigOidDescBuff, expectedBigOidMessage);
    });
    describe(&#039;parameterDescription messages&#039;, function () {
        testForMessage(emptyParameterDescriptionBuffer, expectedEmptyParameterDescriptionMessage);
        testForMessage(oneParameterDescBuf, expectedOneParameterMessage);
        testForMessage(twoParameterDescBuf, expectedTwoParameterMessage);
    });
    describe(&#039;parsing rows&#039;, function () {
        describe(&#039;parsing empty row&#039;, function () {
            testForMessage(emptyRowFieldBuf, {
                name: &#039;dataRow&#039;,
                fieldCount: 0,
            });
        });
        describe(&#039;parsing data row with fields&#039;, function () {
            testForMessage(oneFieldBuf, {
                name: &#039;dataRow&#039;,
                fieldCount: 1,
                fields: [&#039;test&#039;],
            });
        });
    });
    describe(&#039;notice message&#039;, function () {
        // this uses the same logic as error message
        const buff = test_buffers_1.default.notice([{ type: &#039;C&#039;, value: &#039;code&#039; }]);
        testForMessage(buff, {
            name: &#039;notice&#039;,
            code: &#039;code&#039;,
        });
    });
    testForMessage(test_buffers_1.default.error([]), {
        name: &#039;error&#039;,
    });
    describe(&#039;with all the fields&#039;, function () {
        const buffer = test_buffers_1.default.error([
            {
                type: &#039;S&#039;,
                value: &#039;ERROR&#039;,
            },
            {
                type: &#039;C&#039;,
                value: &#039;code&#039;,
            },
            {
                type: &#039;M&#039;,
                value: &#039;message&#039;,
            },
            {
                type: &#039;D&#039;,
                value: &#039;details&#039;,
            },
            {
                type: &#039;H&#039;,
                value: &#039;hint&#039;,
            },
            {
                type: &#039;P&#039;,
                value: &#039;100&#039;,
            },
            {
                type: &#039;p&#039;,
                value: &#039;101&#039;,
            },
            {
                type: &#039;q&#039;,
                value: &#039;query&#039;,
            },
            {
                type: &#039;W&#039;,
                value: &#039;where&#039;,
            },
            {
                type: &#039;F&#039;,
                value: &#039;file&#039;,
            },
            {
                type: &#039;L&#039;,
                value: &#039;line&#039;,
            },
            {
                type: &#039;R&#039;,
                value: &#039;routine&#039;,
            },
            {
                type: &#039;Z&#039;,
                value: &#039;alsdkf&#039;,
            },
        ]);
        testForMessage(buffer, {
            name: &#039;error&#039;,
            severity: &#039;ERROR&#039;,
            code: &#039;code&#039;,
            message: &#039;message&#039;,
            detail: &#039;details&#039;,
            hint: &#039;hint&#039;,
            position: &#039;100&#039;,
            internalPosition: &#039;101&#039;,
            internalQuery: &#039;query&#039;,
            where: &#039;where&#039;,
            file: &#039;file&#039;,
            line: &#039;line&#039;,
            routine: &#039;routine&#039;,
        });
    });
    testForMessage(parseCompleteBuffer, {
        name: &#039;parseComplete&#039;,
    });
    testForMessage(bindCompleteBuffer, {
        name: &#039;bindComplete&#039;,
    });
    testForMessage(bindCompleteBuffer, {
        name: &#039;bindComplete&#039;,
    });
    testForMessage(test_buffers_1.default.closeComplete(), {
        name: &#039;closeComplete&#039;,
    });
    describe(&#039;parses portal suspended message&#039;, function () {
        testForMessage(portalSuspendedBuffer, {
            name: &#039;portalSuspended&#039;,
        });
    });
    describe(&#039;parses replication start message&#039;, function () {
        testForMessage(Buffer.from([0x57, 0x00, 0x00, 0x00, 0x04]), {
            name: &#039;replicationStart&#039;,
            length: 4,
        });
    });
    describe(&#039;copy&#039;, () =&gt; {
        testForMessage(test_buffers_1.default.copyIn(0), {
            name: &#039;copyInResponse&#039;,
            length: 7,
            binary: false,
            columnTypes: [],
        });
        testForMessage(test_buffers_1.default.copyIn(2), {
            name: &#039;copyInResponse&#039;,
            length: 11,
            binary: false,
            columnTypes: [0, 1],
        });
        testForMessage(test_buffers_1.default.copyOut(0), {
            name: &#039;copyOutResponse&#039;,
            length: 7,
            binary: false,
            columnTypes: [],
        });
        testForMessage(test_buffers_1.default.copyOut(3), {
            name: &#039;copyOutResponse&#039;,
            length: 13,
            binary: false,
            columnTypes: [0, 1, 2],
        });
        testForMessage(test_buffers_1.default.copyDone(), {
            name: &#039;copyDone&#039;,
            length: 4,
        });
        testForMessage(test_buffers_1.default.copyData(Buffer.from([5, 6, 7])), {
            name: &#039;copyData&#039;,
            length: 7,
            chunk: Buffer.from([5, 6, 7]),
        });
    });
    // since the data message on a stream can randomly divide the incomming
    // tcp packets anywhere, we need to make sure we can parse every single
    // split on a tcp message
    describe(&#039;split buffer, single message parsing&#039;, function () {
        const fullBuffer = test_buffers_1.default.dataRow([null, &#039;bang&#039;, &#039;zug zug&#039;, null, &#039;!&#039;]);
        it(&#039;parses when full buffer comes in&#039;, function () {
            return __awaiter(this, void 0, void 0, function* () {
                const messages = yield parseBuffers([fullBuffer]);
                const message = messages[0];
                assert_1.default.equal(message.fields.length, 5);
                assert_1.default.equal(message.fields[0], null);
                assert_1.default.equal(message.fields[1], &#039;bang&#039;);
                assert_1.default.equal(message.fields[2], &#039;zug zug&#039;);
                assert_1.default.equal(message.fields[3], null);
                assert_1.default.equal(message.fields[4], &#039;!&#039;);
            });
        });
        const testMessageReceivedAfterSplitAt = function (split) {
            return __awaiter(this, void 0, void 0, function* () {
                const firstBuffer = Buffer.alloc(fullBuffer.length - split);
                const secondBuffer = Buffer.alloc(fullBuffer.length - firstBuffer.length);
                fullBuffer.copy(firstBuffer, 0, 0);
                fullBuffer.copy(secondBuffer, 0, firstBuffer.length);
                const messages = yield parseBuffers([firstBuffer, secondBuffer]);
                const message = messages[0];
                assert_1.default.equal(message.fields.length, 5);
                assert_1.default.equal(message.fields[0], null);
                assert_1.default.equal(message.fields[1], &#039;bang&#039;);
                assert_1.default.equal(message.fields[2], &#039;zug zug&#039;);
                assert_1.default.equal(message.fields[3], null);
                assert_1.default.equal(message.fields[4], &#039;!&#039;);
            });
        };
        it(&#039;parses when split in the middle&#039;, function () {
            return testMessageReceivedAfterSplitAt(6);
        });
        it(&#039;parses when split at end&#039;, function () {
            return testMessageReceivedAfterSplitAt(2);
        });
        it(&#039;parses when split at beginning&#039;, function () {
            return Promise.all([
                testMessageReceivedAfterSplitAt(fullBuffer.length - 2),
                testMessageReceivedAfterSplitAt(fullBuffer.length - 1),
                testMessageReceivedAfterSplitAt(fullBuffer.length - 5),
            ]);
        });
    });
    describe(&#039;split buffer, multiple message parsing&#039;, function () {
        const dataRowBuffer = test_buffers_1.default.dataRow([&#039;!&#039;]);
        const readyForQueryBuffer = test_buffers_1.default.readyForQuery();
        const fullBuffer = Buffer.alloc(dataRowBuffer.length + readyForQueryBuffer.length);
        dataRowBuffer.copy(fullBuffer, 0, 0);
        readyForQueryBuffer.copy(fullBuffer, dataRowBuffer.length, 0);
        const verifyMessages = function (messages) {
            assert_1.default.strictEqual(messages.length, 2);
            assert_1.default.deepEqual(messages[0], {
                name: &#039;dataRow&#039;,
                fieldCount: 1,
                length: 11,
                fields: [&#039;!&#039;],
            });
            assert_1.default.equal(messages[0].fields[0], &#039;!&#039;);
            assert_1.default.deepEqual(messages[1], {
                name: &#039;readyForQuery&#039;,
                length: 5,
                status: &#039;I&#039;,
            });
        };
        // sanity check
        it(&#039;receives both messages when packet is not split&#039;, function () {
            return __awaiter(this, void 0, void 0, function* () {
                const messages = yield parseBuffers([fullBuffer]);
                verifyMessages(messages);
            });
        });
        const splitAndVerifyTwoMessages = function (split) {
            return __awaiter(this, void 0, void 0, function* () {
                const firstBuffer = Buffer.alloc(fullBuffer.length - split);
                const secondBuffer = Buffer.alloc(fullBuffer.length - firstBuffer.length);
                fullBuffer.copy(firstBuffer, 0, 0);
                fullBuffer.copy(secondBuffer, 0, firstBuffer.length);
                const messages = yield parseBuffers([firstBuffer, secondBuffer]);
                verifyMessages(messages);
            });
        };
        describe(&#039;receives both messages when packet is split&#039;, function () {
            it(&#039;in the middle&#039;, function () {
                return splitAndVerifyTwoMessages(11);
            });
            it(&#039;at the front&#039;, function () {
                return Promise.all([
                    splitAndVerifyTwoMessages(fullBuffer.length - 1),
                    splitAndVerifyTwoMessages(fullBuffer.length - 4),
                    splitAndVerifyTwoMessages(fullBuffer.length - 6),
                ]);
            });
            it(&#039;at the end&#039;, function () {
                return Promise.all([splitAndVerifyTwoMessages(8), splitAndVerifyTwoMessages(1)]);
            });
        });
    });
});
//# sourceMappingURL=inbound-parser.test.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
