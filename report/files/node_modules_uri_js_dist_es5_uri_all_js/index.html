<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/uri-js/dist/es5/uri.all.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/uri-js/dist/es5/uri.all.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">54.12</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1444</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">166.96</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">21.46</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function (global, factory) {
	typeof exports === &#039;object&#039; &amp;&amp; typeof module !== &#039;undefined&#039; ? factory(exports) :
	typeof define === &#039;function&#039; &amp;&amp; define.amd ? define([&#039;exports&#039;], factory) :
	(factory((global.URI = global.URI || {})));
}(this, (function (exports) { &#039;use strict&#039;;

function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key &lt; _len; _key++) {
        sets[_key] = arguments[_key];
    }

    if (sets.length &gt; 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x &lt; xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join(&#039;&#039;);
    } else {
        return sets[0];
    }
}
function subexp(str) {
    return &quot;(?:&quot; + str + &quot;)&quot;;
}
function typeOf(o) {
    return o === undefined ? &quot;undefined&quot; : o === null ? &quot;null&quot; : Object.prototype.toString.call(o).split(&quot; &quot;).pop().split(&quot;]&quot;).shift().toLowerCase();
}
function toUpperCase(str) {
    return str.toUpperCase();
}
function toArray(obj) {
    return obj !== undefined &amp;&amp; obj !== null ? obj instanceof Array ? obj : typeof obj.length !== &quot;number&quot; || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
}
function assign(target, source) {
    var obj = target;
    if (source) {
        for (var key in source) {
            obj[key] = source[key];
        }
    }
    return obj;
}

function buildExps(isIRI) {
    var ALPHA$$ = &quot;[A-Za-z]&quot;,
        CR$ = &quot;[\\x0D]&quot;,
        DIGIT$$ = &quot;[0-9]&quot;,
        DQUOTE$$ = &quot;[\\x22]&quot;,
        HEXDIG$$ = merge(DIGIT$$, &quot;[A-Fa-f]&quot;),
        //case-insensitive
    LF$$ = &quot;[\\x0A]&quot;,
        SP$$ = &quot;[\\x20]&quot;,
        PCT_ENCODED$ = subexp(subexp(&quot;%[EFef]&quot; + HEXDIG$$ + &quot;%&quot; + HEXDIG$$ + HEXDIG$$ + &quot;%&quot; + HEXDIG$$ + HEXDIG$$) + &quot;|&quot; + subexp(&quot;%[89A-Fa-f]&quot; + HEXDIG$$ + &quot;%&quot; + HEXDIG$$ + HEXDIG$$) + &quot;|&quot; + subexp(&quot;%&quot; + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = &quot;[\\:\\/\\?\\#\\[\\]\\@]&quot;,
        SUB_DELIMS$$ = &quot;[\\!\\$\\&amp;\\&#039;\\(\\)\\*\\+\\,\\;\\=]&quot;,
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? &quot;[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]&quot; : &quot;[]&quot;,
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? &quot;[\\uE000-\\uF8FF]&quot; : &quot;[]&quot;,
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, &quot;[\\-\\.\\_\\~]&quot;, UCSCHAR$$),
        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, &quot;[\\+\\-\\.]&quot;) + &quot;*&quot;),
        USERINFO$ = subexp(subexp(PCT_ENCODED$ + &quot;|&quot; + merge(UNRESERVED$$, SUB_DELIMS$$, &quot;[\\:]&quot;)) + &quot;*&quot;),
        DEC_OCTET$ = subexp(subexp(&quot;25[0-5]&quot;) + &quot;|&quot; + subexp(&quot;2[0-4]&quot; + DIGIT$$) + &quot;|&quot; + subexp(&quot;1&quot; + DIGIT$$ + DIGIT$$) + &quot;|&quot; + subexp(&quot;[1-9]&quot; + DIGIT$$) + &quot;|&quot; + DIGIT$$),
        DEC_OCTET_RELAXED$ = subexp(subexp(&quot;25[0-5]&quot;) + &quot;|&quot; + subexp(&quot;2[0-4]&quot; + DIGIT$$) + &quot;|&quot; + subexp(&quot;1&quot; + DIGIT$$ + DIGIT$$) + &quot;|&quot; + subexp(&quot;0?[1-9]&quot; + DIGIT$$) + &quot;|0?0?&quot; + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + &quot;\\.&quot; + DEC_OCTET_RELAXED$ + &quot;\\.&quot; + DEC_OCTET_RELAXED$ + &quot;\\.&quot; + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + &quot;{1,4}&quot;),
        LS32$ = subexp(subexp(H16$ + &quot;\\:&quot; + H16$) + &quot;|&quot; + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + &quot;\\:&quot;) + &quot;{6}&quot; + LS32$),
        //                           6( h16 &quot;:&quot; ) ls32
    IPV6ADDRESS2$ = subexp(&quot;\\:\\:&quot; + subexp(H16$ + &quot;\\:&quot;) + &quot;{5}&quot; + LS32$),
        //                      &quot;::&quot; 5( h16 &quot;:&quot; ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + &quot;?\\:\\:&quot; + subexp(H16$ + &quot;\\:&quot;) + &quot;{4}&quot; + LS32$),
        //[               h16 ] &quot;::&quot; 4( h16 &quot;:&quot; ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + &quot;\\:&quot;) + &quot;{0,1}&quot; + H16$) + &quot;?\\:\\:&quot; + subexp(H16$ + &quot;\\:&quot;) + &quot;{3}&quot; + LS32$),
        //[ *1( h16 &quot;:&quot; ) h16 ] &quot;::&quot; 3( h16 &quot;:&quot; ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + &quot;\\:&quot;) + &quot;{0,2}&quot; + H16$) + &quot;?\\:\\:&quot; + subexp(H16$ + &quot;\\:&quot;) + &quot;{2}&quot; + LS32$),
        //[ *2( h16 &quot;:&quot; ) h16 ] &quot;::&quot; 2( h16 &quot;:&quot; ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + &quot;\\:&quot;) + &quot;{0,3}&quot; + H16$) + &quot;?\\:\\:&quot; + H16$ + &quot;\\:&quot; + LS32$),
        //[ *3( h16 &quot;:&quot; ) h16 ] &quot;::&quot;    h16 &quot;:&quot;   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + &quot;\\:&quot;) + &quot;{0,4}&quot; + H16$) + &quot;?\\:\\:&quot; + LS32$),
        //[ *4( h16 &quot;:&quot; ) h16 ] &quot;::&quot;              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + &quot;\\:&quot;) + &quot;{0,5}&quot; + H16$) + &quot;?\\:\\:&quot; + H16$),
        //[ *5( h16 &quot;:&quot; ) h16 ] &quot;::&quot;              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + &quot;\\:&quot;) + &quot;{0,6}&quot; + H16$) + &quot;?\\:\\:&quot;),
        //[ *6( h16 &quot;:&quot; ) h16 ] &quot;::&quot;
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(&quot;|&quot;)),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + &quot;|&quot; + PCT_ENCODED$) + &quot;+&quot;),
        //RFC 6874
    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + &quot;\\%25&quot; + ZONEID$),
        //RFC 6874
    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(&quot;\\%25|\\%(?!&quot; + HEXDIG$$ + &quot;{2})&quot;) + ZONEID$),
        //RFC 6874, with relaxed parsing rules
    IPVFUTURE$ = subexp(&quot;[vV]&quot; + HEXDIG$$ + &quot;+\\.&quot; + merge(UNRESERVED$$, SUB_DELIMS$$, &quot;[\\:]&quot;) + &quot;+&quot;),
        IP_LITERAL$ = subexp(&quot;\\[&quot; + subexp(IPV6ADDRZ_RELAXED$ + &quot;|&quot; + IPV6ADDRESS$ + &quot;|&quot; + IPVFUTURE$) + &quot;\\]&quot;),
        //RFC 6874
    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + &quot;|&quot; + merge(UNRESERVED$$, SUB_DELIMS$$)) + &quot;*&quot;),
        HOST$ = subexp(IP_LITERAL$ + &quot;|&quot; + IPV4ADDRESS$ + &quot;(?!&quot; + REG_NAME$ + &quot;)&quot; + &quot;|&quot; + REG_NAME$),
        PORT$ = subexp(DIGIT$$ + &quot;*&quot;),
        AUTHORITY$ = subexp(subexp(USERINFO$ + &quot;@&quot;) + &quot;?&quot; + HOST$ + subexp(&quot;\\:&quot; + PORT$) + &quot;?&quot;),
        PCHAR$ = subexp(PCT_ENCODED$ + &quot;|&quot; + merge(UNRESERVED$$, SUB_DELIMS$$, &quot;[\\:\\@]&quot;)),
        SEGMENT$ = subexp(PCHAR$ + &quot;*&quot;),
        SEGMENT_NZ$ = subexp(PCHAR$ + &quot;+&quot;),
        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + &quot;|&quot; + merge(UNRESERVED$$, SUB_DELIMS$$, &quot;[\\@]&quot;)) + &quot;+&quot;),
        PATH_ABEMPTY$ = subexp(subexp(&quot;\\/&quot; + SEGMENT$) + &quot;*&quot;),
        PATH_ABSOLUTE$ = subexp(&quot;\\/&quot; + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + &quot;?&quot;),
        //simplified
    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
        //simplified
    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
        //simplified
    PATH_EMPTY$ = &quot;(?!&quot; + PCHAR$ + &quot;)&quot;,
        PATH$ = subexp(PATH_ABEMPTY$ + &quot;|&quot; + PATH_ABSOLUTE$ + &quot;|&quot; + PATH_NOSCHEME$ + &quot;|&quot; + PATH_ROOTLESS$ + &quot;|&quot; + PATH_EMPTY$),
        QUERY$ = subexp(subexp(PCHAR$ + &quot;|&quot; + merge(&quot;[\\/\\?]&quot;, IPRIVATE$$)) + &quot;*&quot;),
        FRAGMENT$ = subexp(subexp(PCHAR$ + &quot;|[\\/\\?]&quot;) + &quot;*&quot;),
        HIER_PART$ = subexp(subexp(&quot;\\/\\/&quot; + AUTHORITY$ + PATH_ABEMPTY$) + &quot;|&quot; + PATH_ABSOLUTE$ + &quot;|&quot; + PATH_ROOTLESS$ + &quot;|&quot; + PATH_EMPTY$),
        URI$ = subexp(SCHEME$ + &quot;\\:&quot; + HIER_PART$ + subexp(&quot;\\?&quot; + QUERY$) + &quot;?&quot; + subexp(&quot;\\#&quot; + FRAGMENT$) + &quot;?&quot;),
        RELATIVE_PART$ = subexp(subexp(&quot;\\/\\/&quot; + AUTHORITY$ + PATH_ABEMPTY$) + &quot;|&quot; + PATH_ABSOLUTE$ + &quot;|&quot; + PATH_NOSCHEME$ + &quot;|&quot; + PATH_EMPTY$),
        RELATIVE$ = subexp(RELATIVE_PART$ + subexp(&quot;\\?&quot; + QUERY$) + &quot;?&quot; + subexp(&quot;\\#&quot; + FRAGMENT$) + &quot;?&quot;),
        URI_REFERENCE$ = subexp(URI$ + &quot;|&quot; + RELATIVE$),
        ABSOLUTE_URI$ = subexp(SCHEME$ + &quot;\\:&quot; + HIER_PART$ + subexp(&quot;\\?&quot; + QUERY$) + &quot;?&quot;),
        GENERIC_REF$ = &quot;^(&quot; + SCHEME$ + &quot;)\\:&quot; + subexp(subexp(&quot;\\/\\/(&quot; + subexp(&quot;(&quot; + USERINFO$ + &quot;)@&quot;) + &quot;?(&quot; + HOST$ + &quot;)&quot; + subexp(&quot;\\:(&quot; + PORT$ + &quot;)&quot;) + &quot;?)&quot;) + &quot;?(&quot; + PATH_ABEMPTY$ + &quot;|&quot; + PATH_ABSOLUTE$ + &quot;|&quot; + PATH_ROOTLESS$ + &quot;|&quot; + PATH_EMPTY$ + &quot;)&quot;) + subexp(&quot;\\?(&quot; + QUERY$ + &quot;)&quot;) + &quot;?&quot; + subexp(&quot;\\#(&quot; + FRAGMENT$ + &quot;)&quot;) + &quot;?$&quot;,
        RELATIVE_REF$ = &quot;^(){0}&quot; + subexp(subexp(&quot;\\/\\/(&quot; + subexp(&quot;(&quot; + USERINFO$ + &quot;)@&quot;) + &quot;?(&quot; + HOST$ + &quot;)&quot; + subexp(&quot;\\:(&quot; + PORT$ + &quot;)&quot;) + &quot;?)&quot;) + &quot;?(&quot; + PATH_ABEMPTY$ + &quot;|&quot; + PATH_ABSOLUTE$ + &quot;|&quot; + PATH_NOSCHEME$ + &quot;|&quot; + PATH_EMPTY$ + &quot;)&quot;) + subexp(&quot;\\?(&quot; + QUERY$ + &quot;)&quot;) + &quot;?&quot; + subexp(&quot;\\#(&quot; + FRAGMENT$ + &quot;)&quot;) + &quot;?$&quot;,
        ABSOLUTE_REF$ = &quot;^(&quot; + SCHEME$ + &quot;)\\:&quot; + subexp(subexp(&quot;\\/\\/(&quot; + subexp(&quot;(&quot; + USERINFO$ + &quot;)@&quot;) + &quot;?(&quot; + HOST$ + &quot;)&quot; + subexp(&quot;\\:(&quot; + PORT$ + &quot;)&quot;) + &quot;?)&quot;) + &quot;?(&quot; + PATH_ABEMPTY$ + &quot;|&quot; + PATH_ABSOLUTE$ + &quot;|&quot; + PATH_ROOTLESS$ + &quot;|&quot; + PATH_EMPTY$ + &quot;)&quot;) + subexp(&quot;\\?(&quot; + QUERY$ + &quot;)&quot;) + &quot;?$&quot;,
        SAMEDOC_REF$ = &quot;^&quot; + subexp(&quot;\\#(&quot; + FRAGMENT$ + &quot;)&quot;) + &quot;?$&quot;,
        AUTHORITY_REF$ = &quot;^&quot; + subexp(&quot;(&quot; + USERINFO$ + &quot;)@&quot;) + &quot;?(&quot; + HOST$ + &quot;)&quot; + subexp(&quot;\\:(&quot; + PORT$ + &quot;)&quot;) + &quot;?$&quot;;
    return {
        NOT_SCHEME: new RegExp(merge(&quot;[^]&quot;, ALPHA$$, DIGIT$$, &quot;[\\+\\-\\.]&quot;), &quot;g&quot;),
        NOT_USERINFO: new RegExp(merge(&quot;[^\\%\\:]&quot;, UNRESERVED$$, SUB_DELIMS$$), &quot;g&quot;),
        NOT_HOST: new RegExp(merge(&quot;[^\\%\\[\\]\\:]&quot;, UNRESERVED$$, SUB_DELIMS$$), &quot;g&quot;),
        NOT_PATH: new RegExp(merge(&quot;[^\\%\\/\\:\\@]&quot;, UNRESERVED$$, SUB_DELIMS$$), &quot;g&quot;),
        NOT_PATH_NOSCHEME: new RegExp(merge(&quot;[^\\%\\/\\@]&quot;, UNRESERVED$$, SUB_DELIMS$$), &quot;g&quot;),
        NOT_QUERY: new RegExp(merge(&quot;[^\\%]&quot;, UNRESERVED$$, SUB_DELIMS$$, &quot;[\\:\\@\\/\\?]&quot;, IPRIVATE$$), &quot;g&quot;),
        NOT_FRAGMENT: new RegExp(merge(&quot;[^\\%]&quot;, UNRESERVED$$, SUB_DELIMS$$, &quot;[\\:\\@\\/\\?]&quot;), &quot;g&quot;),
        ESCAPE: new RegExp(merge(&quot;[^]&quot;, UNRESERVED$$, SUB_DELIMS$$), &quot;g&quot;),
        UNRESERVED: new RegExp(UNRESERVED$$, &quot;g&quot;),
        OTHER_CHARS: new RegExp(merge(&quot;[^\\%]&quot;, UNRESERVED$$, RESERVED$$), &quot;g&quot;),
        PCT_ENCODED: new RegExp(PCT_ENCODED$, &quot;g&quot;),
        IPV4ADDRESS: new RegExp(&quot;^(&quot; + IPV4ADDRESS$ + &quot;)$&quot;),
        IPV6ADDRESS: new RegExp(&quot;^\\[?(&quot; + IPV6ADDRESS$ + &quot;)&quot; + subexp(subexp(&quot;\\%25|\\%(?!&quot; + HEXDIG$$ + &quot;{2})&quot;) + &quot;(&quot; + ZONEID$ + &quot;)&quot;) + &quot;?\\]?$&quot;) //RFC 6874, with relaxed parsing rules
    };
}
var URI_PROTOCOL = buildExps(false);

var IRI_PROTOCOL = buildExps(true);

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i &amp;&amp; _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n &amp;&amp; _i[&quot;return&quot;]) _i[&quot;return&quot;]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError(&quot;Invalid attempt to destructure non-iterable instance&quot;);
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i &lt; arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** Highest positive signed 32-bit float value */

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = &#039;-&#039;; // &#039;\x2D&#039;

/** Regular expressions */
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
	&#039;overflow&#039;: &#039;Overflow: input needs wider integers to process&#039;,
	&#039;not-basic&#039;: &#039;Illegal input &gt;= 0x80 (not a basic code point)&#039;,
	&#039;invalid-input&#039;: &#039;Invalid input&#039;
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error$1(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	var result = [];
	var length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	var parts = string.split(&#039;@&#039;);
	var result = &#039;&#039;;
	if (parts.length &gt; 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + &#039;@&#039;;
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, &#039;\x2E&#039;);
	var labels = string.split(&#039;.&#039;);
	var encoded = map(labels, fn).join(&#039;.&#039;);
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see &lt;https://mathiasbynens.be/notes/javascript-encoding&gt;
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	while (counter &lt; length) {
		var value = string.charCodeAt(counter++);
		if (value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDBFF &amp;&amp; counter &lt; length) {
			// It&#039;s a high surrogate, and there is a next character.
			var extra = string.charCodeAt(counter++);
			if ((extra &amp; 0xFC00) == 0xDC00) {
				// Low surrogate.
				output.push(((value &amp; 0x3FF) &lt;&lt; 10) + (extra &amp; 0x3FF) + 0x10000);
			} else {
				// It&#039;s an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
var ucs2encode = function ucs2encode(array) {
	return String.fromCodePoint.apply(String, toConsumableArray(array));
};

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
var basicToDigit = function basicToDigit(codePoint) {
	if (codePoint - 0x30 &lt; 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 &lt; 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 &lt; 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
var digitToBasic = function digitToBasic(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit &lt; 26) - ((flag != 0) &lt;&lt; 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
var adapt = function adapt(delta, numPoints, firstTime) {
	var k = 0;
	delta = firstTime ? floor(delta / damp) : delta &gt;&gt; 1;
	delta += floor(delta / numPoints);
	for (; /* no initialization */delta &gt; baseMinusTMin * tMax &gt;&gt; 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
var decode = function decode(input) {
	// Don&#039;t use UCS-2.
	var output = [];
	var inputLength = input.length;
	var i = 0;
	var n = initialN;
	var bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	var basic = input.lastIndexOf(delimiter);
	if (basic &lt; 0) {
		basic = 0;
	}

	for (var j = 0; j &lt; basic; ++j) {
		// if it&#039;s not a basic code point
		if (input.charCodeAt(j) &gt;= 0x80) {
			error$1(&#039;not-basic&#039;);
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (var index = basic &gt; 0 ? basic + 1 : 0; index &lt; inputLength;) /* no final expression */{

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		var oldi = i;
		for (var w = 1, k = base;; /* no condition */k += base) {

			if (index &gt;= inputLength) {
				error$1(&#039;invalid-input&#039;);
			}

			var digit = basicToDigit(input.charCodeAt(index++));

			if (digit &gt;= base || digit &gt; floor((maxInt - i) / w)) {
				error$1(&#039;overflow&#039;);
			}

			i += digit * w;
			var t = k &lt;= bias ? tMin : k &gt;= bias + tMax ? tMax : k - bias;

			if (digit &lt; t) {
				break;
			}

			var baseMinusT = base - t;
			if (w &gt; floor(maxInt / baseMinusT)) {
				error$1(&#039;overflow&#039;);
			}

			w *= baseMinusT;
		}

		var out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we&#039;ll fix that now:
		if (floor(i / out) &gt; maxInt - n) {
			error$1(&#039;overflow&#039;);
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);
	}

	return String.fromCodePoint.apply(String, output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
var encode = function encode(input) {
	var output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	var inputLength = input.length;

	// Initialize the state.
	var n = initialN;
	var delta = 0;
	var bias = initialBias;

	// Handle the basic code points.
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _currentValue2 = _step.value;

			if (_currentValue2 &lt; 0x80) {
				output.push(stringFromCharCode(_currentValue2));
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var basicLength = output.length;
	var handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it&#039;s empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount &lt; inputLength) {

		// All non-basic code points &lt; n have been handled already. Find the next
		// larger one:
		var m = maxInt;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var currentValue = _step2.value;

				if (currentValue &gt;= n &amp;&amp; currentValue &lt; m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder&#039;s &lt;n,i&gt; state to &lt;m,0&gt;,
			// but guard against overflow.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 &amp;&amp; _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		var handledCPCountPlusOne = handledCPCount + 1;
		if (m - n &gt; floor((maxInt - delta) / handledCPCountPlusOne)) {
			error$1(&#039;overflow&#039;);
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _currentValue = _step3.value;

				if (_currentValue &lt; n &amp;&amp; ++delta &gt; maxInt) {
					error$1(&#039;overflow&#039;);
				}
				if (_currentValue == n) {
					// Represent delta as a generalized variable-length integer.
					var q = delta;
					for (var k = base;; /* no condition */k += base) {
						var t = k &lt;= bias ? tMin : k &gt;= bias + tMax ? tMax : k - bias;
						if (q &lt; t) {
							break;
						}
						var qMinusT = q - t;
						var baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 &amp;&amp; _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		++delta;
		++n;
	}
	return output.join(&#039;&#039;);
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn&#039;t matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
var toUnicode = function toUnicode(input) {
	return mapDomain(input, function (string) {
		return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn&#039;t matter if you call it with a domain that&#039;s already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
var toASCII = function toASCII(input) {
	return mapDomain(input, function (string) {
		return regexNonASCII.test(string) ? &#039;xn--&#039; + encode(string) : string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
var punycode = {
	/**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */
	&#039;version&#039;: &#039;2.1.0&#039;,
	/**
  * An object of methods to convert from JavaScript&#039;s internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see &lt;https://mathiasbynens.be/notes/javascript-encoding&gt;
  * @memberOf punycode
  * @type Object
  */
	&#039;ucs2&#039;: {
		&#039;decode&#039;: ucs2decode,
		&#039;encode&#039;: ucs2encode
	},
	&#039;decode&#039;: decode,
	&#039;encode&#039;: encode,
	&#039;toASCII&#039;: toASCII,
	&#039;toUnicode&#039;: toUnicode
};

/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author &lt;a href=&quot;mailto:gary.court@gmail.com&quot;&gt;Gary Court&lt;/a&gt;
 * @see http://github.com/garycourt/uri-js
 */
/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS&#039;&#039; AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */
var SCHEMES = {};
function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c &lt; 16) e = &quot;%0&quot; + c.toString(16).toUpperCase();else if (c &lt; 128) e = &quot;%&quot; + c.toString(16).toUpperCase();else if (c &lt; 2048) e = &quot;%&quot; + (c &gt;&gt; 6 | 192).toString(16).toUpperCase() + &quot;%&quot; + (c &amp; 63 | 128).toString(16).toUpperCase();else e = &quot;%&quot; + (c &gt;&gt; 12 | 224).toString(16).toUpperCase() + &quot;%&quot; + (c &gt;&gt; 6 &amp; 63 | 128).toString(16).toUpperCase() + &quot;%&quot; + (c &amp; 63 | 128).toString(16).toUpperCase();
    return e;
}
function pctDecChars(str) {
    var newStr = &quot;&quot;;
    var i = 0;
    var il = str.length;
    while (i &lt; il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c &lt; 128) {
            newStr += String.fromCharCode(c);
            i += 3;
        } else if (c &gt;= 194 &amp;&amp; c &lt; 224) {
            if (il - i &gt;= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c &amp; 31) &lt;&lt; 6 | c2 &amp; 63);
            } else {
                newStr += str.substr(i, 6);
            }
            i += 6;
        } else if (c &gt;= 224) {
            if (il - i &gt;= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c &amp; 15) &lt;&lt; 12 | (_c &amp; 63) &lt;&lt; 6 | c3 &amp; 63);
            } else {
                newStr += str.substr(i, 9);
            }
            i += 9;
        } else {
            newStr += str.substr(i, 3);
            i += 3;
        }
    }
    return newStr;
}
function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }
    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, &quot;&quot;);
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
}

function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, &quot;$1&quot;) || &quot;0&quot;;
}
function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
        return address.split(&quot;.&quot;).map(_stripLeadingZeros).join(&quot;.&quot;);
    } else {
        return host;
    }
}
function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split(&#039;::&#039;).reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];

        var firstFields = first ? first.split(&quot;:&quot;).map(_stripLeadingZeros) : [];
        var lastFields = last.split(&quot;:&quot;).map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x &lt; fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || &#039;&#039;;
        }
        if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === &quot;0&quot;) {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest &amp;&amp; lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                } else {
                    acc.push({ index: index, length: 1 });
                }
            }
            return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields &amp;&amp; longestZeroFields.length &gt; 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(&quot;:&quot;) + &quot;::&quot; + newLast.join(&quot;:&quot;);
        } else {
            newHost = fields.join(&quot;:&quot;);
        }
        if (zone) {
            newHost += &quot;%&quot; + zone;
        }
        return newHost;
    } else {
        return host;
    }
}
var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
var NO_MATCH_IS_UNDEFINED = &quot;&quot;.match(/(){0}/)[1] === undefined;
function parse(uriString) {
    var options = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : {};

    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === &quot;suffix&quot;) uriString = (options.scheme ? options.scheme + &quot;:&quot; : &quot;&quot;) + &quot;//&quot; + uriString;
    var matches = uriString.match(URI_PARSE);
    if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || &quot;&quot;;
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
                components.port = matches[5];
            }
        } else {
            //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = uriString.indexOf(&quot;@&quot;) !== -1 ? matches[3] : undefined;
            components.host = uriString.indexOf(&quot;//&quot;) !== -1 ? matches[4] : undefined;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || &quot;&quot;;
            components.query = uriString.indexOf(&quot;?&quot;) !== -1 ? matches[7] : undefined;
            components.fragment = uriString.indexOf(&quot;#&quot;) !== -1 ? matches[8] : undefined;
            //fix port number
            if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
            }
        }
        if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        //determine reference type
        if (components.scheme === undefined &amp;&amp; components.userinfo === undefined &amp;&amp; components.host === undefined &amp;&amp; components.port === undefined &amp;&amp; !components.path &amp;&amp; components.query === undefined) {
            components.reference = &quot;same-document&quot;;
        } else if (components.scheme === undefined) {
            components.reference = &quot;relative&quot;;
        } else if (components.fragment === undefined) {
            components.reference = &quot;absolute&quot;;
        } else {
            components.reference = &quot;uri&quot;;
        }
        //check for reference errors
        if (options.reference &amp;&amp; options.reference !== &quot;suffix&quot; &amp;&amp; options.reference !== components.reference) {
            components.error = components.error || &quot;URI is not a &quot; + options.reference + &quot; reference.&quot;;
        }
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || &quot;&quot;).toLowerCase()];
        //check if scheme can&#039;t handle IRIs
        if (!options.unicodeSupport &amp;&amp; (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host &amp;&amp; (options.domainHost || schemeHandler &amp;&amp; schemeHandler.domainHost)) {
                //convert Unicode IDN -&gt; ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || &quot;Host&#039;s domain name can not be converted to ASCII via punycode: &quot; + e;
                }
            }
            //convert IRI -&gt; URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
        }
        //perform scheme specific parsing
        if (schemeHandler &amp;&amp; schemeHandler.parse) {
            schemeHandler.parse(components, options);
        }
    } else {
        components.error = components.error || &quot;URI can not be parsed.&quot;;
    }
    return components;
}

function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push(&quot;@&quot;);
    }
    if (components.host !== undefined) {
        //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
            return &quot;[&quot; + $1 + ($2 ? &quot;%25&quot; + $2 : &quot;&quot;) + &quot;]&quot;;
        }));
    }
    if (typeof components.port === &quot;number&quot; || typeof components.port === &quot;string&quot;) {
        uriTokens.push(&quot;:&quot;);
        uriTokens.push(String(components.port));
    }
    return uriTokens.length ? uriTokens.join(&quot;&quot;) : undefined;
}

var RDS1 = /^\.\.?\//;
var RDS2 = /^\/\.(\/|$)/;
var RDS3 = /^\/\.\.(\/|$)/;
var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
function removeDotSegments(input) {
    var output = [];
    while (input.length) {
        if (input.match(RDS1)) {
            input = input.replace(RDS1, &quot;&quot;);
        } else if (input.match(RDS2)) {
            input = input.replace(RDS2, &quot;/&quot;);
        } else if (input.match(RDS3)) {
            input = input.replace(RDS3, &quot;/&quot;);
            output.pop();
        } else if (input === &quot;.&quot; || input === &quot;..&quot;) {
            input = &quot;&quot;;
        } else {
            var im = input.match(RDS5);
            if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
            } else {
                throw new Error(&quot;Unexpected dot segment condition&quot;);
            }
        }
    }
    return output.join(&quot;&quot;);
}

function serialize(components) {
    var options = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : {};

    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    //find scheme handler
    var schemeHandler = SCHEMES[(options.scheme || components.scheme || &quot;&quot;).toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler &amp;&amp; schemeHandler.serialize) schemeHandler.serialize(components, options);
    if (components.host) {
        //if host component is an IPv6 address
        if (protocol.IPV6ADDRESS.test(components.host)) {}
        //TODO: normalize IPv6 address as per RFC 5952

        //if host component is a domain name
        else if (options.domainHost || schemeHandler &amp;&amp; schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || &quot;Host&#039;s domain name can not be converted to &quot; + (!options.iri ? &quot;ASCII&quot; : &quot;Unicode&quot;) + &quot; via punycode: &quot; + e;
                }
            }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== &quot;suffix&quot; &amp;&amp; components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(&quot;:&quot;);
    }
    var authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
        if (options.reference !== &quot;suffix&quot;) {
            uriTokens.push(&quot;//&quot;);
        }
        uriTokens.push(authority);
        if (components.path &amp;&amp; components.path.charAt(0) !== &quot;/&quot;) {
            uriTokens.push(&quot;/&quot;);
        }
    }
    if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath &amp;&amp; (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined) {
            s = s.replace(/^\/\//, &quot;/%2F&quot;); //don&#039;t allow the path to start with &quot;//&quot;
        }
        uriTokens.push(s);
    }
    if (components.query !== undefined) {
        uriTokens.push(&quot;?&quot;);
        uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
        uriTokens.push(&quot;#&quot;);
        uriTokens.push(components.fragment);
    }
    return uriTokens.join(&quot;&quot;); //merge tokens into a string
}

function resolveComponents(base, relative) {
    var options = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];

    var target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); //normalize base components
        relative = parse(serialize(relative, options), options); //normalize relative components
    }
    options = options || {};
    if (!options.tolerant &amp;&amp; relative.scheme) {
        target.scheme = relative.scheme;
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || &quot;&quot;);
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || &quot;&quot;);
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path.charAt(0) === &quot;/&quot;) {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) &amp;&amp; !base.path) {
                        target.path = &quot;/&quot; + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf(&quot;/&quot;) + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            //target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}

function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({ scheme: &#039;null&#039; }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
}

function normalize(uri, options) {
    if (typeof uri === &quot;string&quot;) {
        uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === &quot;object&quot;) {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}

function equal(uriA, uriB, options) {
    if (typeof uriA === &quot;string&quot;) {
        uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === &quot;object&quot;) {
        uriA = serialize(uriA, options);
    }
    if (typeof uriB === &quot;string&quot;) {
        uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === &quot;object&quot;) {
        uriB = serialize(uriB, options);
    }
    return uriA === uriB;
}

function escapeComponent(str, options) {
    return str &amp;&amp; str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
}

function unescapeComponent(str, options) {
    return str &amp;&amp; str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
}

var handler = {
    scheme: &quot;http&quot;,
    domainHost: true,
    parse: function parse(components, options) {
        //report missing host
        if (!components.host) {
            components.error = components.error || &quot;HTTP URIs must have a host.&quot;;
        }
        return components;
    },
    serialize: function serialize(components, options) {
        var secure = String(components.scheme).toLowerCase() === &quot;https&quot;;
        //normalize the default port
        if (components.port === (secure ? 443 : 80) || components.port === &quot;&quot;) {
            components.port = undefined;
        }
        //normalize the empty path
        if (!components.path) {
            components.path = &quot;/&quot;;
        }
        //NOTE: We do not parse query strings for HTTP URIs
        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
        //and not the HTTP spec.
        return components;
    }
};

var handler$1 = {
    scheme: &quot;https&quot;,
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
};

function isSecure(wsComponents) {
    return typeof wsComponents.secure === &#039;boolean&#039; ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === &quot;wss&quot;;
}
//RFC 6455
var handler$2 = {
    scheme: &quot;ws&quot;,
    domainHost: true,
    parse: function parse(components, options) {
        var wsComponents = components;
        //indicate if the secure flag is set
        wsComponents.secure = isSecure(wsComponents);
        //construct resouce name
        wsComponents.resourceName = (wsComponents.path || &#039;/&#039;) + (wsComponents.query ? &#039;?&#039; + wsComponents.query : &#039;&#039;);
        wsComponents.path = undefined;
        wsComponents.query = undefined;
        return wsComponents;
    },
    serialize: function serialize(wsComponents, options) {
        //normalize the default port
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === &quot;&quot;) {
            wsComponents.port = undefined;
        }
        //ensure scheme matches secure flag
        if (typeof wsComponents.secure === &#039;boolean&#039;) {
            wsComponents.scheme = wsComponents.secure ? &#039;wss&#039; : &#039;ws&#039;;
            wsComponents.secure = undefined;
        }
        //reconstruct path from resource name
        if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split(&#039;?&#039;),
                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
                path = _wsComponents$resourc2[0],
                query = _wsComponents$resourc2[1];

            wsComponents.path = path &amp;&amp; path !== &#039;/&#039; ? path : undefined;
            wsComponents.query = query;
            wsComponents.resourceName = undefined;
        }
        //forbid fragment component
        wsComponents.fragment = undefined;
        return wsComponents;
    }
};

var handler$3 = {
    scheme: &quot;wss&quot;,
    domainHost: handler$2.domainHost,
    parse: handler$2.parse,
    serialize: handler$2.serialize
};

var O = {};
var isIRI = true;
//RFC 3986
var UNRESERVED$$ = &quot;[A-Za-z0-9\\-\\.\\_\\~&quot; + (isIRI ? &quot;\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF&quot; : &quot;&quot;) + &quot;]&quot;;
var HEXDIG$$ = &quot;[0-9A-Fa-f]&quot;; //case-insensitive
var PCT_ENCODED$ = subexp(subexp(&quot;%[EFef]&quot; + HEXDIG$$ + &quot;%&quot; + HEXDIG$$ + HEXDIG$$ + &quot;%&quot; + HEXDIG$$ + HEXDIG$$) + &quot;|&quot; + subexp(&quot;%[89A-Fa-f]&quot; + HEXDIG$$ + &quot;%&quot; + HEXDIG$$ + HEXDIG$$) + &quot;|&quot; + subexp(&quot;%&quot; + HEXDIG$$ + HEXDIG$$)); //expanded
//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] &amp; ; =
//const ATEXT$$ = &quot;[A-Za-z0-9\\!\\#\\$\\%\\&amp;\\&#039;\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]&quot;;
//const WSP$$ = &quot;[\\x20\\x09]&quot;;
//const OBS_QTEXT$$ = &quot;[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]&quot;;  //(%d1-8 / %d11-12 / %d14-31 / %d127)
//const QTEXT$$ = merge(&quot;[\\x21\\x23-\\x5B\\x5D-\\x7E]&quot;, OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
//const VCHAR$$ = &quot;[\\x21-\\x7E]&quot;;
//const WSP$$ = &quot;[\\x20\\x09]&quot;;
//const OBS_QP$ = subexp(&quot;\\\\&quot; + merge(&quot;[\\x00\\x0D\\x0A]&quot;, OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
//const FWS$ = subexp(subexp(WSP$$ + &quot;*&quot; + &quot;\\x0D\\x0A&quot;) + &quot;?&quot; + WSP$$ + &quot;+&quot;);
//const QUOTED_PAIR$ = subexp(subexp(&quot;\\\\&quot; + subexp(VCHAR$$ + &quot;|&quot; + WSP$$)) + &quot;|&quot; + OBS_QP$);
//const QUOTED_STRING$ = subexp(&#039;\\&quot;&#039; + subexp(FWS$ + &quot;?&quot; + QCONTENT$) + &quot;*&quot; + FWS$ + &quot;?&quot; + &#039;\\&quot;&#039;);
var ATEXT$$ = &quot;[A-Za-z0-9\\!\\$\\%\\&#039;\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]&quot;;
var QTEXT$$ = &quot;[\\!\\$\\%\\&#039;\\(\\)\\*\\+\\,\\-\\.0-9\\&lt;\\&gt;A-Z\\x5E-\\x7E]&quot;;
var VCHAR$$ = merge(QTEXT$$, &quot;[\\\&quot;\\\\]&quot;);
var SOME_DELIMS$$ = &quot;[\\!\\$\\&#039;\\(\\)\\*\\+\\,\\;\\:\\@]&quot;;
var UNRESERVED = new RegExp(UNRESERVED$$, &quot;g&quot;);
var PCT_ENCODED = new RegExp(PCT_ENCODED$, &quot;g&quot;);
var NOT_LOCAL_PART = new RegExp(merge(&quot;[^]&quot;, ATEXT$$, &quot;[\\.]&quot;, &#039;[\\&quot;]&#039;, VCHAR$$), &quot;g&quot;);
var NOT_HFNAME = new RegExp(merge(&quot;[^]&quot;, UNRESERVED$$, SOME_DELIMS$$), &quot;g&quot;);
var NOT_HFVALUE = NOT_HFNAME;
function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
}
var handler$4 = {
    scheme: &quot;mailto&quot;,
    parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(&quot;,&quot;) : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split(&quot;&amp;&quot;);
            for (var x = 0, xl = hfields.length; x &lt; xl; ++x) {
                var hfield = hfields[x].split(&quot;=&quot;);
                switch (hfield[0]) {
                    case &quot;to&quot;:
                        var toAddrs = hfield[1].split(&quot;,&quot;);
                        for (var _x = 0, _xl = toAddrs.length; _x &lt; _xl; ++_x) {
                            to.push(toAddrs[_x]);
                        }
                        break;
                    case &quot;subject&quot;:
                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                        break;
                    case &quot;body&quot;:
                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                        break;
                    default:
                        unknownHeaders = true;
                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                        break;
                }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length; _x2 &lt; _xl2; ++_x2) {
            var addr = to[_x2].split(&quot;@&quot;);
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
                //convert Unicode IDN -&gt; ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || &quot;Email address&#039;s domain name can not be converted to ASCII via punycode: &quot; + e;
                }
            } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join(&quot;@&quot;);
        }
        return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
            for (var x = 0, xl = to.length; x &lt; xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf(&quot;@&quot;);
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                //convert IDN via punycode
                try {
                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e) {
                    components.error = components.error || &quot;Email address&#039;s domain name can not be converted to &quot; + (!options.iri ? &quot;ASCII&quot; : &quot;Unicode&quot;) + &quot; via punycode: &quot; + e;
                }
                to[x] = localPart + &quot;@&quot; + domain;
            }
            components.path = to.join(&quot;,&quot;);
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject) headers[&quot;subject&quot;] = mailtoComponents.subject;
        if (mailtoComponents.body) headers[&quot;body&quot;] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
            if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + &quot;=&quot; + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
        }
        if (fields.length) {
            components.query = fields.join(&quot;&amp;&quot;);
        }
        return components;
    }
};

var URN_PARSE = /^([^\:]+)\:(.*)/;
//RFC 2141
var handler$5 = {
    scheme: &quot;urn&quot;,
    parse: function parse$$1(components, options) {
        var matches = components.path &amp;&amp; components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
            var scheme = options.scheme || urnComponents.scheme || &quot;urn&quot;;
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + &quot;:&quot; + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = undefined;
            if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
            }
        } else {
            urnComponents.error = urnComponents.error || &quot;URN can not be parsed.&quot;;
        }
        return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || &quot;urn&quot;;
        var nid = urnComponents.nid;
        var urnScheme = scheme + &quot;:&quot; + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + &quot;:&quot; + nss;
        return uriComponents;
    }
};

var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
//RFC 4122
var handler$6 = {
    scheme: &quot;urn:uuid&quot;,
    parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant &amp;&amp; (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || &quot;UUID is not valid.&quot;;
        }
        return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        //normalize UUID
        urnComponents.nss = (uuidComponents.uuid || &quot;&quot;).toLowerCase();
        return urnComponents;
    }
};

SCHEMES[handler.scheme] = handler;
SCHEMES[handler$1.scheme] = handler$1;
SCHEMES[handler$2.scheme] = handler$2;
SCHEMES[handler$3.scheme] = handler$3;
SCHEMES[handler$4.scheme] = handler$4;
SCHEMES[handler$5.scheme] = handler$5;
SCHEMES[handler$6.scheme] = handler$6;

exports.SCHEMES = SCHEMES;
exports.pctEncChar = pctEncChar;
exports.pctDecChars = pctDecChars;
exports.parse = parse;
exports.removeDotSegments = removeDotSegments;
exports.serialize = serialize;
exports.resolveComponents = resolveComponents;
exports.resolve = resolve;
exports.normalize = normalize;
exports.equal = equal;
exports.escapeComponent = escapeComponent;
exports.unescapeComponent = unescapeComponent;

Object.defineProperty(exports, &#039;__esModule&#039;, { value: true });

})));
//# sourceMappingURL=uri.all.js.map
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
