<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/eslint/lib/linter/apply-disable-directives.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/eslint/lib/linter/apply-disable-directives.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.79</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">585</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">91.29</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.13</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview A module that filters reported problems based on `eslint-disable` and `eslint-enable` comments
 * @author Teddy Katz
 */

&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

/** @typedef {import(&quot;../types&quot;).Linter.LintMessage} LintMessage */
/** @typedef {import(&quot;@eslint/core&quot;).Language} Language */
/** @typedef {import(&quot;@eslint/core&quot;).Position} Position */
/** @typedef {import(&quot;@eslint/core&quot;).RulesConfig} RulesConfig */

//------------------------------------------------------------------------------
// Module Definition
//------------------------------------------------------------------------------

const escapeRegExp = require(&quot;escape-string-regexp&quot;);
const { Config } = require(&quot;../config/config.js&quot;);

/**
 * Compares the locations of two objects in a source file
 * @param {Position} itemA The first object
 * @param {Position} itemB The second object
 * @returns {number} A value less than 1 if itemA appears before itemB in the source file, greater than 1 if
 * itemA appears after itemB in the source file, or 0 if itemA and itemB have the same location.
 */
function compareLocations(itemA, itemB) {
	return itemA.line - itemB.line || itemA.column - itemB.column;
}

/**
 * Groups a set of directives into sub-arrays by their parent comment.
 * @param {Iterable&lt;Directive&gt;} directives Unused directives to be removed.
 * @returns {Directive[][]} Directives grouped by their parent comment.
 */
function groupByParentDirective(directives) {
	const groups = new Map();

	for (const directive of directives) {
		const {
			unprocessedDirective: { parentDirective },
		} = directive;

		if (groups.has(parentDirective)) {
			groups.get(parentDirective).push(directive);
		} else {
			groups.set(parentDirective, [directive]);
		}
	}

	return [...groups.values()];
}

/**
 * Creates removal details for a set of directives within the same comment.
 * @param {Directive[]} directives Unused directives to be removed.
 * @param {{node: Token, value: string}} parentDirective Data about the backing directive.
 * @param {SourceCode} sourceCode The source code object for the file being linted.
 * @returns {{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.
 */
function createIndividualDirectivesRemoval(
	directives,
	parentDirective,
	sourceCode,
) {
	/*
	 * Get the list of the rules text without any surrounding whitespace. In order to preserve the original
	 * formatting, we don&#039;t want to change that whitespace.
	 *
	 *     // eslint-disable-line rule-one , rule-two , rule-three -- comment
	 *                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	 */
	const listText = parentDirective.value.trim();

	// Calculate where it starts in the source code text
	const listStart = sourceCode.text.indexOf(
		listText,
		sourceCode.getRange(parentDirective.node)[0],
	);

	/*
	 * We can assume that `listText` contains multiple elements.
	 * Otherwise, this function wouldn&#039;t be called - if there is
	 * only one rule in the list, then the whole comment must be removed.
	 */

	return directives.map(directive =&gt; {
		const { ruleId } = directive;

		const regex = new RegExp(
			String.raw`(?:^|\s*,\s*)(?&lt;quote&gt;[&#039;&quot;]?)${escapeRegExp(ruleId)}\k&lt;quote&gt;(?:\s*,\s*|$)`,
			&quot;u&quot;,
		);
		const match = regex.exec(listText);
		const matchedText = match[0];
		const matchStart = listStart + match.index;
		const matchEnd = matchStart + matchedText.length;

		const firstIndexOfComma = matchedText.indexOf(&quot;,&quot;);
		const lastIndexOfComma = matchedText.lastIndexOf(&quot;,&quot;);

		let removalStart, removalEnd;

		if (firstIndexOfComma !== lastIndexOfComma) {
			/*
			 * Since there are two commas, this must one of the elements in the middle of the list.
			 * Matched range starts where the previous rule name ends, and ends where the next rule name starts.
			 *
			 *     // eslint-disable-line rule-one , rule-two , rule-three -- comment
			 *                                    ^^^^^^^^^^^^^^
			 *
			 * We want to remove only the content between the two commas, and also one of the commas.
			 *
			 *     // eslint-disable-line rule-one , rule-two , rule-three -- comment
			 *                                     ^^^^^^^^^^^
			 */
			removalStart = matchStart + firstIndexOfComma;
			removalEnd = matchStart + lastIndexOfComma;
		} else {
			/*
			 * This is either the first element or the last element.
			 *
			 * If this is the first element, matched range starts where the first rule name starts
			 * and ends where the second rule name starts. This is exactly the range we want
			 * to remove so that the second rule name will start where the first one was starting
			 * and thus preserve the original formatting.
			 *
			 *     // eslint-disable-line rule-one , rule-two , rule-three -- comment
			 *                            ^^^^^^^^^^^
			 *
			 * Similarly, if this is the last element, we&#039;ve already matched the range we want to
			 * remove. The previous rule name will end where the last one was ending, relative
			 * to the content on the right side.
			 *
			 *     // eslint-disable-line rule-one , rule-two , rule-three -- comment
			 *                                               ^^^^^^^^^^^^^
			 */
			removalStart = matchStart;
			removalEnd = matchEnd;
		}

		return {
			description: `&#039;${ruleId}&#039;`,
			fix: {
				range: [removalStart, removalEnd],
				text: &quot;&quot;,
			},
			unprocessedDirective: directive.unprocessedDirective,
		};
	});
}

/**
 * Creates a description of deleting an entire unused disable directive.
 * @param {Directive[]} directives Unused directives to be removed.
 * @param {Token} node The backing Comment token.
 * @param {SourceCode} sourceCode The source code object for the file being linted.
 * @returns {{ description, fix, unprocessedDirective }} Details for later creation of an output problem.
 */
function createDirectiveRemoval(directives, node, sourceCode) {
	const range = sourceCode.getRange(node);
	const ruleIds = directives
		.filter(directive =&gt; directive.ruleId)
		.map(directive =&gt; `&#039;${directive.ruleId}&#039;`);

	return {
		description:
			ruleIds.length &lt;= 2
				? ruleIds.join(&quot; or &quot;)
				: `${ruleIds.slice(0, ruleIds.length - 1).join(&quot;, &quot;)}, or ${ruleIds.at(-1)}`,
		fix: {
			range,
			text: &quot; &quot;,
		},
		unprocessedDirective: directives[0].unprocessedDirective,
	};
}

/**
 * Parses details from directives to create output Problems.
 * @param {Iterable&lt;Directive&gt;} allDirectives Unused directives to be removed.
 * @param {SourceCode} sourceCode The source code object for the file being linted.
 * @returns {{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.
 */
function processUnusedDirectives(allDirectives, sourceCode) {
	const directiveGroups = groupByParentDirective(allDirectives);

	return directiveGroups.flatMap(directives =&gt; {
		const { parentDirective } = directives[0].unprocessedDirective;
		const remainingRuleIds = new Set(parentDirective.ruleIds);

		for (const directive of directives) {
			remainingRuleIds.delete(directive.ruleId);
		}

		return remainingRuleIds.size
			? createIndividualDirectivesRemoval(
					directives,
					parentDirective,
					sourceCode,
				)
			: [
					createDirectiveRemoval(
						directives,
						parentDirective.node,
						sourceCode,
					),
				];
	});
}

/**
 * Collect eslint-enable comments that are removing suppressions by eslint-disable comments.
 * @param {Directive[]} directives The directives to check.
 * @returns {Set&lt;Directive&gt;} The used eslint-enable comments
 */
function collectUsedEnableDirectives(directives) {
	/**
	 * A Map of `eslint-enable` keyed by ruleIds that may be marked as used.
	 * If `eslint-enable` does not have a ruleId, the key will be `null`.
	 * @type {Map&lt;string|null, Directive&gt;}
	 */
	const enabledRules = new Map();

	/**
	 * A Set of `eslint-enable` marked as used.
	 * It is also the return value of `collectUsedEnableDirectives` function.
	 * @type {Set&lt;Directive&gt;}
	 */
	const usedEnableDirectives = new Set();

	/*
	 * Checks the directives backwards to see if the encountered `eslint-enable` is used by the previous `eslint-disable`,
	 * and if so, stores the `eslint-enable` in `usedEnableDirectives`.
	 */
	for (let index = directives.length - 1; index &gt;= 0; index--) {
		const directive = directives[index];

		if (directive.type === &quot;disable&quot;) {
			if (enabledRules.size === 0) {
				continue;
			}
			if (directive.ruleId === null) {
				// If encounter `eslint-disable` without ruleId,
				// mark all `eslint-enable` currently held in enabledRules as used.
				// e.g.
				//    /* eslint-disable */ &lt;- current directive
				//    /* eslint-enable rule-id1 */ &lt;- used
				//    /* eslint-enable rule-id2 */ &lt;- used
				//    /* eslint-enable */ &lt;- used
				for (const enableDirective of enabledRules.values()) {
					usedEnableDirectives.add(enableDirective);
				}
				enabledRules.clear();
			} else {
				const enableDirective = enabledRules.get(directive.ruleId);

				if (enableDirective) {
					// If encounter `eslint-disable` with ruleId, and there is an `eslint-enable` with the same ruleId in enabledRules,
					// mark `eslint-enable` with ruleId as used.
					// e.g.
					//    /* eslint-disable rule-id */ &lt;- current directive
					//    /* eslint-enable rule-id */ &lt;- used
					usedEnableDirectives.add(enableDirective);
				} else {
					const enabledDirectiveWithoutRuleId =
						enabledRules.get(null);

					if (enabledDirectiveWithoutRuleId) {
						// If encounter `eslint-disable` with ruleId, and there is no `eslint-enable` with the same ruleId in enabledRules,
						// mark `eslint-enable` without ruleId as used.
						// e.g.
						//    /* eslint-disable rule-id */ &lt;- current directive
						//    /* eslint-enable */ &lt;- used
						usedEnableDirectives.add(enabledDirectiveWithoutRuleId);
					}
				}
			}
		} else if (directive.type === &quot;enable&quot;) {
			if (directive.ruleId === null) {
				// If encounter `eslint-enable` without ruleId, the `eslint-enable` that follows it are unused.
				// So clear enabledRules.
				// e.g.
				//    /* eslint-enable */ &lt;- current directive
				//    /* eslint-enable rule-id *// &lt;- unused
				//    /* eslint-enable */ &lt;- unused
				enabledRules.clear();
				enabledRules.set(null, directive);
			} else {
				enabledRules.set(directive.ruleId, directive);
			}
		}
	}
	return usedEnableDirectives;
}

/**
 * This is the same as the exported function, except that it
 * doesn&#039;t handle disable-line and disable-next-line directives, and it always reports unused
 * disable directives.
 * @param {Object} options options for applying directives. This is the same as the options
 * for the exported function, except that `reportUnusedDisableDirectives` is not supported
 * (this function always reports unused disable directives).
 * @returns {{problems: LintMessage[], unusedDirectives: LintMessage[]}} An object with a list
 * of problems (including suppressed ones) and unused eslint-disable directives
 */
function applyDirectives(options) {
	const problems = [];
	const usedDisableDirectives = new Set();
	const { sourceCode } = options;

	for (const problem of options.problems) {
		let disableDirectivesForProblem = [];
		let nextDirectiveIndex = 0;

		while (
			nextDirectiveIndex &lt; options.directives.length &amp;&amp;
			compareLocations(options.directives[nextDirectiveIndex], problem) &lt;=
				0
		) {
			const directive = options.directives[nextDirectiveIndex++];

			if (
				directive.ruleId === null ||
				directive.ruleId === problem.ruleId
			) {
				switch (directive.type) {
					case &quot;disable&quot;:
						disableDirectivesForProblem.push(directive);
						break;

					case &quot;enable&quot;:
						disableDirectivesForProblem = [];
						break;

					// no default
				}
			}
		}

		if (disableDirectivesForProblem.length &gt; 0) {
			const suppressions = disableDirectivesForProblem.map(directive =&gt; ({
				kind: &quot;directive&quot;,
				justification: directive.unprocessedDirective.justification,
			}));

			if (problem.suppressions) {
				problem.suppressions =
					problem.suppressions.concat(suppressions);
			} else {
				problem.suppressions = suppressions;
				usedDisableDirectives.add(disableDirectivesForProblem.at(-1));
			}
		}

		problems.push(problem);
	}

	const unusedDisableDirectivesToReport = options.directives.filter(
		directive =&gt;
			directive.type === &quot;disable&quot; &amp;&amp;
			!usedDisableDirectives.has(directive) &amp;&amp;
			!options.rulesToIgnore.has(directive.ruleId),
	);

	const unusedEnableDirectivesToReport = new Set(
		options.directives.filter(
			directive =&gt;
				directive.unprocessedDirective.type === &quot;enable&quot; &amp;&amp;
				!options.rulesToIgnore.has(directive.ruleId),
		),
	);

	/*
	 * If directives has the eslint-enable directive,
	 * check whether the eslint-enable comment is used.
	 */
	if (unusedEnableDirectivesToReport.size &gt; 0) {
		for (const directive of collectUsedEnableDirectives(
			options.directives,
		)) {
			unusedEnableDirectivesToReport.delete(directive);
		}
	}

	const processed = processUnusedDirectives(
		unusedDisableDirectivesToReport,
		sourceCode,
	).concat(
		processUnusedDirectives(unusedEnableDirectivesToReport, sourceCode),
	);
	const columnOffset = options.language.columnStart === 1 ? 0 : 1;
	const lineOffset = options.language.lineStart === 1 ? 0 : 1;

	const unusedDirectives = processed.map(
		({ description, fix, unprocessedDirective }) =&gt; {
			const { parentDirective, type, line, column } =
				unprocessedDirective;

			let message;

			if (type === &quot;enable&quot;) {
				message = description
					? `Unused eslint-enable directive (no matching eslint-disable directives were found for ${description}).`
					: &quot;Unused eslint-enable directive (no matching eslint-disable directives were found).&quot;;
			} else {
				message = description
					? `Unused eslint-disable directive (no problems were reported from ${description}).`
					: &quot;Unused eslint-disable directive (no problems were reported).&quot;;
			}

			const loc = sourceCode.getLoc(parentDirective.node);

			return {
				ruleId: null,
				message,
				line:
					type === &quot;disable-next-line&quot;
						? loc.start.line + lineOffset
						: line,
				column:
					type === &quot;disable-next-line&quot;
						? loc.start.column + columnOffset
						: column,
				severity:
					options.reportUnusedDisableDirectives === &quot;warn&quot; ? 1 : 2,
				nodeType: null,
				...(options.disableFixes ? {} : { fix }),
			};
		},
	);

	return { problems, unusedDirectives };
}

/**
 * Given a list of directive comments (i.e. metadata about eslint-disable and eslint-enable comments) and a list
 * of reported problems, adds the suppression information to the problems.
 * @param {Object} options Information about directives and problems
 * @param {Language} options.language The language being linted.
 * @param {SourceCode} options.sourceCode The source code object for the file being linted.
 * @param {{
 *      type: (&quot;disable&quot;|&quot;enable&quot;|&quot;disable-line&quot;|&quot;disable-next-line&quot;),
 *      ruleId: (string|null),
 *      line: number,
 *      column: number,
 *      justification: string
 * }} options.directives Directive comments found in the file, with one-based columns.
 * Two directive comments can only have the same location if they also have the same type (e.g. a single eslint-disable
 * comment for two different rules is represented as two directives).
 * @param {{ruleId: (string|null), line: number, column: number}[]} options.problems
 * A list of problems reported by rules, sorted by increasing location in the file, with one-based columns.
 * @param {&quot;off&quot; | &quot;warn&quot; | &quot;error&quot;} options.reportUnusedDisableDirectives If `&quot;warn&quot;` or `&quot;error&quot;`, adds additional problems for unused directives
 * @param {RulesConfig} options.configuredRules The rules configuration.
 * @param {Function} options.ruleFilter A predicate function to filter which rules should be executed.
 * @param {boolean} options.disableFixes If true, it doesn&#039;t make `fix` properties.
 * @returns {{ruleId: (string|null), line: number, column: number, suppressions?: {kind: string, justification: string}}[]}
 * An object with a list of reported problems, the suppressed of which contain the suppression information.
 */
module.exports = ({
	language,
	sourceCode,
	directives,
	disableFixes,
	problems,
	configuredRules,
	ruleFilter,
	reportUnusedDisableDirectives = &quot;off&quot;,
}) =&gt; {
	const blockDirectives = directives
		.filter(
			directive =&gt;
				directive.type === &quot;disable&quot; || directive.type === &quot;enable&quot;,
		)
		.map(directive =&gt;
			Object.assign({}, directive, { unprocessedDirective: directive }),
		)
		.sort(compareLocations);

	const lineDirectives = directives
		.flatMap(directive =&gt; {
			switch (directive.type) {
				case &quot;disable&quot;:
				case &quot;enable&quot;:
					return [];

				case &quot;disable-line&quot;:
					return [
						{
							type: &quot;disable&quot;,
							line: directive.line,
							column: 1,
							ruleId: directive.ruleId,
							unprocessedDirective: directive,
						},
						{
							type: &quot;enable&quot;,
							line: directive.line + 1,
							column: 0,
							ruleId: directive.ruleId,
							unprocessedDirective: directive,
						},
					];

				case &quot;disable-next-line&quot;:
					return [
						{
							type: &quot;disable&quot;,
							line: directive.line + 1,
							column: 1,
							ruleId: directive.ruleId,
							unprocessedDirective: directive,
						},
						{
							type: &quot;enable&quot;,
							line: directive.line + 2,
							column: 0,
							ruleId: directive.ruleId,
							unprocessedDirective: directive,
						},
					];

				default:
					throw new TypeError(
						`Unrecognized directive type &#039;${directive.type}&#039;`,
					);
			}
		})
		.sort(compareLocations);

	// This determines a list of rules that are not being run by the given ruleFilter, if present.
	const rulesToIgnore =
		configuredRules &amp;&amp; ruleFilter
			? new Set(
					Object.keys(configuredRules).filter(ruleId =&gt; {
						const severity = Config.getRuleNumericSeverity(
							configuredRules[ruleId],
						);

						// Ignore for disabled rules.
						if (severity === 0) {
							return false;
						}

						return !ruleFilter({ severity, ruleId });
					}),
				)
			: new Set();

	// If no ruleId is supplied that means this directive is applied to all rules, so we can&#039;t determine if it&#039;s unused if any rules are filtered out.
	if (rulesToIgnore.size &gt; 0) {
		rulesToIgnore.add(null);
	}

	const blockDirectivesResult = applyDirectives({
		language,
		sourceCode,
		problems,
		directives: blockDirectives,
		disableFixes,
		reportUnusedDisableDirectives,
		rulesToIgnore,
	});
	const lineDirectivesResult = applyDirectives({
		language,
		sourceCode,
		problems: blockDirectivesResult.problems,
		directives: lineDirectives,
		disableFixes,
		reportUnusedDisableDirectives,
		rulesToIgnore,
	});

	return reportUnusedDisableDirectives !== &quot;off&quot;
		? lineDirectivesResult.problems
				.concat(blockDirectivesResult.unusedDirectives)
				.concat(lineDirectivesResult.unusedDirectives)
				.sort(compareLocations)
		: lineDirectivesResult.problems;
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
