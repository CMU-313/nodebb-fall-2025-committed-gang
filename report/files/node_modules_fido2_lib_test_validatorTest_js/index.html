<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/fido2-lib/test/validatorTest.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/fido2-lib/test/validatorTest.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">76.20</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1121</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">63.41</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">15.53</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

const validator = require(&quot;../lib/validator&quot;);
const parser = require(&quot;../lib/parser&quot;);
const chai = require(&quot;chai&quot;);
var chaiAsPromised = require(&quot;chai-as-promised&quot;);
chai.use(chaiAsPromised);
var assert = chai.assert;
const h = require(&quot;fido2-helpers&quot;);
const { coerceToArrayBuffer } = require(&quot;../lib/utils&quot;);
const {
	printHex,
	cloneObject,
} = h.functions;

var attResp;

var runs = [
	{ functionName: &quot;parseAuthnrAttestationResponse&quot; },
	{ functionName: &quot;parseAttestationObject&quot; },
];

describe(&quot;attestation validation&quot;, function() {

	runs.forEach(function(run) {

		describe(&quot;parsing attestation with &quot; + run.functionName, function() {

			beforeEach(function() {
				attResp = {
					request: {},
					requiredExpectations: new Set([
						&quot;origin&quot;,
						&quot;challenge&quot;,
						&quot;flags&quot;,
					]),
					optionalExpectations: new Set([
						&quot;rpId&quot;,
						&quot;allowCredentials&quot;,
					]),
					expectations: new Map([
						[&quot;origin&quot;, &quot;https://localhost:8443&quot;],
						[&quot;challenge&quot;, &quot;33EHav-jZ1v9qwH783aU-j0ARx6r5o-YHh-wd7C6jPbd7Wh6ytbIZosIIACehwf9-s6hXhySHO-HHUjEwZS29w&quot;],
						[&quot;flags&quot;, [&quot;UP&quot;, &quot;AT&quot;]],
					]),
					clientData: parser.parseClientResponse(h.lib.makeCredentialAttestationNoneResponse),
					authnrData: run.functionName == &quot;parseAuthnrAttestationResponse&quot; ? parser[run.functionName](h.lib.makeCredentialAttestationNoneResponse) :  parser[run.functionName](h.lib.makeCredentialAttestationNoneResponse.response.attestationObject),
				};
				var testReq = cloneObject(h.lib.makeCredentialAttestationNoneResponse);
				testReq.rawId = h.lib.makeCredentialAttestationNoneResponse.rawId;
				testReq.response.clientDataJSON = h.lib.makeCredentialAttestationNoneResponse.response.clientDataJSON.slice(0);
				testReq.response.attestationObject = h.lib.makeCredentialAttestationNoneResponse.response.attestationObject.slice(0);
				attResp.request = testReq;

				validator.attach(attResp);
			});

			it(&quot;returns object&quot;, function() {
				assert.isObject(validator);
			});

			it(&quot;is attached&quot;, function() {
				assert.isFunction(validator.attach);
				assert.isFunction(attResp.validateOrigin);
				assert.isFunction(attResp.validateAttestation);
			});

			describe(&quot;validateExpectations&quot;, function() {
				it(&quot;returns true on valid expectations&quot;, async function() {
					var ret = await attResp.validateExpectations();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.validExpectations);
				});

				it(&quot;throws if expectations aren&#039;t found&quot;, function() {
					delete attResp.expectations;
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expectations should be of type Map&quot;);
				});

				it(&quot;throws if expectations aren&#039;t Map&quot;, function() {
					attResp.expectations = {};
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expectations should be of type Map&quot;);
				});

				it(&quot;throws if optionalExpectations aren&#039;t Set&quot;, function() {
					attResp.optionalExpectations = { rpId: true };
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;optionalExpectations should be of type Set&quot;);
				});

				it(&quot;should not throw if  optionalExpectations are array&quot;, async function() {
					attResp.optionalExpectations = [&quot;rpId&quot;];
					assert.isFulfilled(attResp.validateExpectations());
				});

				it(&quot;throws if too many expectations&quot;, function() {
					attResp.expectations.set(&quot;foo&quot;, &quot;bar&quot;);
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;wrong number of expectations: should have 3 but got 4&quot;);
				});

				it(&quot;throws if too many expectations, but expectations are valid&quot;, function() {
					attResp.expectations.set(&quot;prevCounter&quot;, 42);
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;wrong number of expectations: should have 3 but got 4&quot;);
				});

				it(&quot;throws if missing challenge&quot;, function() {
					attResp.expectations.delete(&quot;challenge&quot;);
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expectation did not contain value for &#039;challenge&#039;&quot;);
				});

				it(&quot;throws if missing flags&quot;, function() {
					attResp.expectations.delete(&quot;flags&quot;);
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expectation did not contain value for &#039;flags&#039;&quot;);
				});

				it(&quot;throws if missing origin&quot;, function() {
					attResp.expectations.delete(&quot;origin&quot;);
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expectation did not contain value for &#039;origin&#039;&quot;);
				});

				it(&quot;throws if challenge is undefined&quot;, function() {
					attResp.expectations.set(&quot;challenge&quot;, undefined);
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expected challenge should be of type String, got: undefined&quot;);
				});

				it(&quot;throws if challenge isn&#039;t string&quot;, function() {
					attResp.expectations.set(&quot;challenge&quot;, { foo: &quot;bar&quot; });
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expected challenge should be of type String, got: object&quot;);
				});

				it(&quot;throws if challenge isn&#039;t base64 encoded string&quot;, function() {
					attResp.expectations.set(&quot;challenge&quot;, &quot;miles&amp;me&quot;);
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expected challenge should be properly encoded base64url String&quot;);
				});

				it(&quot;calls checkOrigin&quot;);

				it(&quot;returns true if flags is Set&quot;, async function() {
					attResp.expectations.set(&quot;flags&quot;, new Set([&quot;UP&quot;, &quot;AT&quot;]));
					var ret = await attResp.validateExpectations();
					assert.isTrue(ret);
				});

				it(&quot;throws if Set contains non-string&quot;, function() {
					attResp.expectations.set(&quot;flags&quot;, new Set([3, &quot;UP&quot;, &quot;AT&quot;]));
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expected flag unknown: 3&quot;);
				});

				it(&quot;throws if Array contains non-string&quot;, function() {
					attResp.expectations.set(&quot;flags&quot;, [3, &quot;UP&quot;, &quot;AT&quot;]);
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expected flag unknown: 3&quot;);
				});

				it(&quot;throws on unknown flag&quot;, function() {
					attResp.expectations.set(&quot;flags&quot;, new Set([&quot;foo&quot;, &quot;UP&quot;, &quot;AT&quot;]));
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expected flag unknown: foo&quot;);
				});

				it(&quot;throws on undefined flag&quot;, function() {
					attResp.expectations.set(&quot;flags&quot;, new Set([undefined, &quot;UP&quot;, &quot;AT&quot;]));
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expected flag unknown: undefined&quot;);
				});

				it(&quot;throws on invalid rpId type&quot;, function() {
					attResp.expectations.set(&quot;rpId&quot;, 123);
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;rpId must be a string&quot;);
				});

				it(&quot;throws on invalid rpId&quot;, function() {
					attResp.expectations.set(&quot;rpId&quot;, &quot;test&quot;);
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;rpId is not a valid eTLD+1&quot;);
				});

				it(&quot;works with valid rpId&quot;, async function() {
					attResp.expectations.set(&quot;rpId&quot;, &quot;google.com&quot;);
					var ret = await attResp.validateExpectations();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.validExpectations);
				});

				it(&quot;works with localhost rpId&quot;, async function() {
					attResp.expectations.set(&quot;rpId&quot;, &quot;localhost&quot;);
					var ret = await attResp.validateExpectations();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.validExpectations);
				});

				it(&quot;works with valid allowCredentials&quot;, async function() {
					attResp.expectations.set(&quot;allowCredentials&quot;, [{ id: h.lib.assertionResponse.rawId, type: &quot;public-key&quot;, transports: [&quot;usb&quot;, &quot;nfc&quot;] }]);
					var ret = await attResp.validateExpectations();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.validExpectations);
				});

				it(&quot;works with null allowCredentials&quot;, async function() {
					attResp.expectations.set(&quot;allowCredentials&quot;, null);
					var ret = await attResp.validateExpectations();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.validExpectations);
				});

				it(&quot;throws on wrong allowCredentials type&quot;, function() {
					attResp.expectations.set(&quot;allowCredentials&quot;, { type: &quot;public-key&quot;, transports: [&quot;usb&quot;, &quot;nfc&quot;] });
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expected allowCredentials to be null or array&quot;);
				});

				it(&quot;throws on missing id in allowCredentials&quot;, function() {
					attResp.expectations.set(&quot;allowCredentials&quot;, [{ type: &quot;public-key&quot;, transports: [&quot;usb&quot;, &quot;nfc&quot;] }]);
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expected id of allowCredentials[0] to be ArrayBuffer&quot;);
				});

				it(&quot;throws on null id in allowCredentials&quot;, function() {
					attResp.expectations.set(&quot;allowCredentials&quot;, [{ id: {}, type: &quot;public-key&quot;, transports: [&quot;usb&quot;, &quot;nfc&quot;] }]);
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expected id of allowCredentials[0] to be ArrayBuffer&quot;);
				});

				it(&quot;throws on wrong type of id in allowCredentials&quot;, function() {
					attResp.expectations.set(&quot;allowCredentials&quot;, [{ id: {}, type: &quot;public-key&quot;, transports: [&quot;usb&quot;, &quot;nfc&quot;] }]);
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expected id of allowCredentials[0] to be ArrayBuffer&quot;);
				});

				it(&quot;throws on missing type in allowCredentials element&quot;, function() {
					attResp.expectations.set(&quot;allowCredentials&quot;, [{ id: h.lib.assertionResponse.rawId, transports: [&quot;usb&quot;, &quot;nfc&quot;] }]);
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expected type of allowCredentials[0] to be string with value &#039;public-key&#039;&quot;);
				});

				it(&quot;throws on wrong type value in allowCredentials element&quot;, function() {
					attResp.expectations.set(&quot;allowCredentials&quot;, [{ id: h.lib.assertionResponse.rawId, type: &quot;test&quot;, transports: [&quot;usb&quot;, &quot;nfc&quot;] }]);
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expected type of allowCredentials[0] to be string with value &#039;public-key&#039;&quot;);
				});

				it(&quot;throws on wrong transports type in allowCredentials element&quot;, function() {
					attResp.expectations.set(&quot;allowCredentials&quot;, [{ id: h.lib.assertionResponse.rawId, type: &quot;public-key&quot;, transports: &quot;test&quot; }]);
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expected transports of allowCredentials[0] to be array or null&quot;);
				});

				it(&quot;throws on wrong transports value in allowCredentials element&quot;, function() {
					attResp.expectations.set(&quot;allowCredentials&quot;, [{ id: h.lib.assertionResponse.rawId, type: &quot;public-key&quot;, transports: [&quot;none&quot;, &quot;nfc&quot;] }]);
					return assert.isRejected(attResp.validateExpectations(), Error, &quot;expected transports of allowCredentials[0] to be string with value &#039;usb&#039;, &#039;nfc&#039;, &#039;ble&#039;, &#039;internal&#039; or null&quot;);
				});

				it(&quot;works with null transports in allowCredentials element&quot;, async function() {
					attResp.expectations.set(&quot;allowCredentials&quot;, [{ id: h.lib.assertionResponse.rawId, type: &quot;public-key&quot; }]);
					var ret = await attResp.validateExpectations();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.validExpectations);
				});

				it(&quot;throws if counter is not a number&quot;);
				it(&quot;throws if counter is negative&quot;);
				it(&quot;throws if publicKey is not a string&quot;);
				it(&quot;throws if publicKey doesn&#039;t match PEM regexp&quot;);

				it(&quot;throws if requiredExpectations is undefined&quot;);
				it(&quot;throws if requiredExpectations is not Array or Set&quot;);
				it(&quot;passes if requiredExpectations is Array&quot;);
				it(&quot;passes if requiredExpectations is Set&quot;);
				it(&quot;throws if requiredExpectations field is missing&quot;);
				it(&quot;throws if more expectations were passed than requiredExpectations&quot;);
			});

			describe(&quot;validateCreateRequest&quot;, function() {
				it(&quot;returns true if request is valid&quot;, function() {
					var ret = attResp.validateCreateRequest();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.validRequest);
				});

				it(&quot;returns true for U2F request&quot;, function() {
					var ret = attResp.validateCreateRequest();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.validRequest);
				});

				it(&quot;throws if request is undefined&quot;, function() {
					attResp.request = undefined;
					assert.throws(() =&gt; {
						attResp.validateCreateRequest();
					}, TypeError, &quot;expected request to be Object, got undefined&quot;);
				});

				it(&quot;throws if response field is undefined&quot;, function() {
					delete attResp.request.response;
					assert.throws(() =&gt; {
						attResp.validateCreateRequest();
					}, TypeError, &quot;expected &#039;response&#039; field of request to be Object, got undefined&quot;);
				});

				it(&quot;throws if response field is non-object&quot;, function() {
					attResp.request.response = 3;
					assert.throws(() =&gt; {
						attResp.validateCreateRequest();
					}, TypeError, &quot;expected &#039;response&#039; field of request to be Object, got number&quot;);
				});

				it(&quot;throws if id field is undefined&quot;, function() {
					delete attResp.request.id;
					delete attResp.request.rawId;
					assert.throws(() =&gt; {
						attResp.validateCreateRequest();
					}, TypeError, &quot;expected &#039;id&#039; or &#039;rawId&#039; field of request to be ArrayBuffer, got rawId undefined and id undefined&quot;);
				});

				it(&quot;throws if id field is non-string&quot;, function() {
					attResp.request.rawId = [];
					delete attResp.request.id;
					assert.throws(() =&gt; {
						attResp.validateCreateRequest();
					}, TypeError, &quot;expected &#039;id&#039; or &#039;rawId&#039; field of request to be ArrayBuffer, got rawId object and id undefined&quot;);
				});

				it(&quot;throws if response.attestationObject is undefined&quot;, function() {
					delete attResp.request.response.attestationObject;
					assert.throws(() =&gt; {
						attResp.validateCreateRequest();
					}, TypeError, &quot;expected &#039;response.attestationObject&#039; to be base64 String or ArrayBuffer&quot;);
				});

				it(&quot;throws if response.attestationObject is non-ArrayBuffer &amp; non-String&quot;, function() {
					attResp.request.response.attestationObject = {};
					assert.throws(() =&gt; {
						attResp.validateCreateRequest();
					}, TypeError, &quot;expected &#039;response.attestationObject&#039; to be base64 String or ArrayBuffer&quot;);
				});

				it(&quot;passes with response.attestationObject as ArrayBuffer&quot;, async function() {
					attResp.request.response.attestationObject = new ArrayBuffer();
					var ret = await attResp.validateCreateRequest();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.validRequest);
				});

				it(&quot;passes with response.attestationObject as String&quot;, async function() {
					attResp.request.response.attestationObject = &quot;&quot;;
					var ret = await attResp.validateCreateRequest();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.validRequest);
				});

				it(&quot;throws if response.clientDataJSON is undefined&quot;, function() {
					delete attResp.request.response.clientDataJSON;
					assert.throws(() =&gt; {
						attResp.validateCreateRequest();
					}, TypeError, &quot;expected &#039;response.clientDataJSON&#039; to be base64 String or ArrayBuffer&quot;);
				});

				it(&quot;throws if response.clientDataJSON is non-ArrayBuffer &amp; non-String&quot;, function() {
					attResp.request.response.clientDataJSON = {};
					assert.throws(() =&gt; {
						attResp.validateCreateRequest();
					}, TypeError, &quot;expected &#039;response.clientDataJSON&#039; to be base64 String or ArrayBuffer&quot;);
				});

				it(&quot;passes with response.clientDataJSON as ArrayBuffer&quot;, async function() {
					attResp.request.response.clientDataJSON = new ArrayBuffer();
					var ret = await attResp.validateCreateRequest();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.validRequest);
				});

				it(&quot;passes with response.clientDataJSON as String&quot;, async function() {
					attResp.request.response.clientDataJSON = &quot;&quot;;
					var ret = await attResp.validateCreateRequest();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.validRequest);
				});
			});

			describe(&quot;validateRawClientDataJson&quot;, function() {
				it(&quot;returns true if ArrayBuffer&quot;, async function() {
					var ret = await attResp.validateRawClientDataJson();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;rawClientDataJson&quot;));
				});

				it(&quot;throws if missing&quot;, function() {
					attResp.clientData.delete(&quot;rawClientDataJson&quot;);
					return assert.isRejected(attResp.validateRawClientDataJson(), Error, &quot;clientData clientDataJson should be ArrayBuffer&quot;);
				});

				it(&quot;throws if not ArrayBuffer&quot;, function() {
					attResp.clientData.set(&quot;rawClientDataJson&quot;, &quot;foo&quot;);
					return assert.isRejected(attResp.validateRawClientDataJson(), Error, &quot;clientData clientDataJson should be ArrayBuffer&quot;);
				});
			});

			describe(&quot;validateId&quot;, function() {
				it(&quot;returns true on ArrayBuffer&quot;, async function() {
					var ret = await attResp.validateId();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;rawId&quot;));
				});

				it(&quot;throws on non-ArrayBuffer&quot;, function() {
					attResp.clientData.set(&quot;id&quot;, {});
					attResp.clientData.set(&quot;rawId&quot;, {});
					return assert.isRejected(attResp.validateId(), Error, &quot;expected id to be of type ArrayBuffer&quot;);
				});

				it(&quot;throws on undefined&quot;, function() {
					attResp.clientData.set(&quot;id&quot;, undefined);
					attResp.clientData.set(&quot;rawId&quot;, undefined);
					return assert.isRejected(attResp.validateId(), Error, &quot;expected id to be of type ArrayBuffer&quot;);
				});
			});

			describe(&quot;validateTransports&quot;, function() {
				it(&quot;returns true on array&lt;string&gt;&quot;, async function() {
					var ret = await attResp.validateTransports();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;transports&quot;));
				});

				it(&quot;returns true on null&quot;, async function() {
					var ret = await attResp.validateTransports();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;transports&quot;));
				});

				it(&quot;throws on non-Array&quot;, function() {
					attResp.authnrData.set(&quot;transports&quot;, &quot;test&quot;);
					return assert.isRejected(attResp.validateTransports(), Error, &quot;expected transports to be &#039;null&#039; or &#039;array&lt;string&gt;&#039;&quot;);
				});

				it(&quot;throws on non-Array&lt;string&gt;&quot;, function() {
					attResp.authnrData.set(&quot;transports&quot;, [1]);
					return assert.isRejected(attResp.validateTransports(), Error, &quot;expected transports[0] to be &#039;string&#039;&quot;);
				});

			});

			describe(&quot;validateOrigin&quot;, function() {
				it(&quot;accepts exact match&quot;, async function() {
					attResp.expectations.set(&quot;origin&quot;, &quot;https://webauthn.bin.coffee:8080&quot;);
					attResp.clientData.set(&quot;origin&quot;, &quot;https://webauthn.bin.coffee:8080&quot;);
					var ret = await attResp.validateOrigin();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;origin&quot;));
				});

				it(&quot;throws on port mismatch&quot;, function() {
					attResp.expectations.set(&quot;origin&quot;, &quot;https://webauthn.bin.coffee:8080&quot;);
					attResp.clientData.set(&quot;origin&quot;, &quot;https://webauthn.bin.coffee:8443&quot;);
					return assert.isRejected(attResp.validateOrigin(), Error, &quot;clientData origin did not match expected origin&quot;);
				});

				it(&quot;throws on domain mismatch&quot;, function() {
					attResp.expectations.set(&quot;origin&quot;, &quot;https://webauthn.bin.coffee:8080&quot;);
					attResp.clientData.set(&quot;origin&quot;, &quot;https://bin.coffee:8080&quot;);
					return assert.isRejected(attResp.validateOrigin(), Error, &quot;clientData origin did not match expected origin&quot;);
				});

				it(&quot;throws on protocol mismatch&quot;, function() {
					attResp.expectations.set(&quot;origin&quot;, &quot;http://webauthn.bin.coffee:8080&quot;);
					attResp.clientData.set(&quot;origin&quot;, &quot;https://webauthn.bin.coffee:8080&quot;);
					return assert.isRejected(attResp.validateOrigin(), Error, &quot;clientData origin did not match expected origin&quot;);
				});

				it(&quot;calls checkOrigin&quot;);
			});

			describe(&quot;checkOrigin&quot;, function() { });

			describe(&quot;validateCreateType&quot;, function() {
				it(&quot;returns true when &#039;webauthn.create&#039;&quot;, async function() {
					var ret = await attResp.validateCreateType();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;type&quot;));
				});

				it(&quot;throws when undefined&quot;, function() {
					attResp.clientData.set(&quot;type&quot;, undefined);
					return assert.isRejected(attResp.validateCreateType(), Error, &quot;clientData type should be &#039;webauthn.create&#039;&quot;);
				});

				it(&quot;throws on &#039;webauthn.get&#039;&quot;, function() {
					attResp.clientData.set(&quot;type&quot;, &quot;webauthn.get&quot;);
					return assert.isRejected(attResp.validateCreateType(), Error, &quot;clientData type should be &#039;webauthn.create&#039;&quot;);
				});

				it(&quot;throws on unknown string&quot;, function() {
					attResp.clientData.set(&quot;type&quot;, &quot;asdf&quot;);
					return assert.isRejected(attResp.validateCreateType(), Error, &quot;clientData type should be &#039;webauthn.create&#039;&quot;);
				});
			});

			describe(&quot;validateGetType&quot;, function() {
				it(&quot;returns true when &#039;webauthn.get&#039;&quot;, async function() {
					attResp.clientData.set(&quot;type&quot;, &quot;webauthn.get&quot;);
					var ret = await attResp.validateGetType();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;type&quot;));
				});

				it(&quot;throws when undefined&quot;, function() {
					attResp.clientData.set(&quot;type&quot;, undefined);
					return assert.isRejected(attResp.validateGetType(), Error, &quot;clientData type should be &#039;webauthn.get&#039;&quot;);
				});

				it(&quot;throws on &#039;webauthn.create&#039;&quot;, function() {
					attResp.clientData.set(&quot;type&quot;, &quot;webauthn.create&quot;);
					return assert.isRejected(attResp.validateGetType(), &quot;clientData type should be &#039;webauthn.get&#039;&quot;);
				});

				it(&quot;throws on unknown string&quot;, function() {
					attResp.clientData.set(&quot;type&quot;, &quot;asdf&quot;);
					return assert.isRejected(attResp.validateGetType(), &quot;clientData type should be &#039;webauthn.get&#039;&quot;);
				});
			});

			describe(&quot;validateChallenge&quot;, function() {
				it(&quot;returns true if challenges match&quot;, async function() {
					attResp.expectations.set(&quot;challenge&quot;, &quot;33EHav-jZ1v9qwH783aU-j0ARx6r5o-YHh-wd7C6jPbd7Wh6ytbIZosIIACehwf9-s6hXhySHO-HHUjEwZS29w&quot;);
					var ret = await attResp.validateChallenge();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;challenge&quot;));
				});

				it(&quot;accepts ending equal sign (1)&quot;, async function() {
					attResp.expectations.set(&quot;challenge&quot;, &quot;33EHav-jZ1v9qwH783aU-j0ARx6r5o-YHh-wd7C6jPbd7Wh6ytbIZosIIACehwf9-s6hXhySHO-HHUjEwZS29w&quot;);
					attResp.clientData.set(&quot;challenge&quot;, &quot;33EHav-jZ1v9qwH783aU-j0ARx6r5o-YHh-wd7C6jPbd7Wh6ytbIZosIIACehwf9-s6hXhySHO-HHUjEwZS29w=&quot;);
					var ret = await attResp.validateChallenge();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;challenge&quot;));
				});

				it(&quot;accepts ending equal signs (2)&quot;, async function() {
					attResp.expectations.set(&quot;challenge&quot;, &quot;33EHav-jZ1v9qwH783aU-j0ARx6r5o-YHh-wd7C6jPbd7Wh6ytbIZosIIACehwf9-s6hXhySHO-HHUjEwZS29w&quot;);
					attResp.clientData.set(&quot;challenge&quot;, &quot;33EHav-jZ1v9qwH783aU-j0ARx6r5o-YHh-wd7C6jPbd7Wh6ytbIZosIIACehwf9-s6hXhySHO-HHUjEwZS29w==&quot;);
					var ret = await attResp.validateChallenge();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;challenge&quot;));
				});

				it(&quot;throws on three equal signs&quot;, function() {
					attResp.expectations.set(&quot;challenge&quot;, &quot;33EHav-jZ1v9qwH783aU-j0ARx6r5o-YHh-wd7C6jPbd7Wh6ytbIZosIIACehwf9-s6hXhySHO-HHUjEwZS29w&quot;);
					attResp.clientData.set(&quot;challenge&quot;, &quot;33EHav-jZ1v9qwH783aU-j0ARx6r5o-YHh-wd7C6jPbd7Wh6ytbIZosIIACehwf9-s6hXhySHO-HHUjEwZS29w===&quot;);
					return assert.isRejected(attResp.validateChallenge(), Error, &quot;clientData challenge was not properly encoded base64url&quot;);
				});

				it(&quot;does not remove equal sign from middle of string&quot;, function() {
					attResp.expectations.set(&quot;challenge&quot;, &quot;33EHav-jZ1v9qwH783aU-j0ARx6r5o-YHh-wd7C6jPbd7Wh6ytbIZosIIACehwf9-s6hXhySHO-HHUjEwZS29w&quot;);
					attResp.clientData.set(&quot;challenge&quot;, &quot;33EHav-jZ1v9qwH783aU-j0A=Rx6r5o-YHh-wd7C6jPbd7Wh6ytbIZosIIACehwf9-s6hXhySHO-HHUjEwZS29w&quot;);
					return assert.isRejected(attResp.validateChallenge(), Error, &quot;clientData challenge was not properly encoded base64url&quot;);
				});

				it(&quot;throws if challenge is not a string&quot;, function() {
					attResp.expectations.set(&quot;challenge&quot;, &quot;33EHav-jZ1v9qwH783aU-j0ARx6r5o-YHh-wd7C6jPbd7Wh6ytbIZosIIACehwf9-s6hXhySHO-HHUjEwZS29w&quot;);
					attResp.clientData.set(&quot;challenge&quot;, [&quot;foo&quot;]);
					return assert.isRejected(attResp.validateChallenge(), Error, &quot;clientData challenge was not a string&quot;);
				});

				it(&quot;throws if challenge is base64url encoded&quot;, function() {
					attResp.expectations.set(&quot;challenge&quot;, &quot;4BS1YJKRCeCVoLdfG_b66BuSQ-I2n34WsLFvy62fpIVFjrm32_tFRQixX9U8EBVTriTkreAp-1nDvYboRK9WFg&quot;);
					attResp.clientData.set(&quot;challenge&quot;, &quot;4BS1YJKRCeCVoLdfG/b66BuSQ+I2n34WsLFvy62fpIVFjrm32/tFRQixX9U8EBVTriTkreAp+1nDvYboRK9WFg&quot;);
					return assert.isRejected(attResp.validateChallenge(), Error, &quot;clientData challenge was not properly encoded base64url&quot;);
				});

				it(&quot;throws if challenge is not base64 string&quot;, function() {
					attResp.expectations.set(&quot;challenge&quot;, &quot;33EHav-jZ1v9qwH783aU-j0ARx6r5o-YHh-wd7C6jPbd7Wh6ytbIZosIIACehwf9-s6hXhySHO-HHUjEwZS29w&quot;);
					attResp.clientData.set(&quot;challenge&quot;, &quot;miles&amp;me&quot;);
					return assert.isRejected(attResp.validateChallenge(), Error, &quot;clientData challenge was not properly encoded base64url&quot;);
				});

				it(&quot;throws on undefined challenge&quot;, function() {
					attResp.expectations.set(&quot;challenge&quot;, &quot;33EHav-jZ1v9qwH783aU-j0ARx6r5o-YHh-wd7C6jPbd7Wh6ytbIZosIIACehwf9-s6hXhySHO-HHUjEwZS29w&quot;);
					attResp.clientData.set(&quot;challenge&quot;, undefined);
					return assert.isRejected(attResp.validateChallenge(), Error, &quot;clientData challenge was not a string&quot;);
				});

				it(&quot;throws on challenge mismatch&quot;, function() {
					attResp.expectations.set(&quot;challenge&quot;, &quot;33EHav-jZ1v9qwH783aU-j0ARx6r5o-YHh-wd7C6jPbd7Wh6ytbIZosIIACehwf9-s6hXhySHO-HHUjEwZS29w&quot;);
					attResp.clientData.set(&quot;challenge&quot;, &quot;4BS1YJKRCeCVoLdfG_b66BuSQ-I2n34WsLFvy62fpIVFjrm32_tFRQixX9U8EBVTriTkreAp-1nDvYboRK9WFg&quot;);
					return assert.isRejected(attResp.validateChallenge(), Error, &quot;clientData challenge mismatch&quot;);
				});
			});

			describe(&quot;validateRawAuthnrData&quot;, function() {
				it(&quot;returns true if ArrayBuffer&quot;, async function() {
					var ret = await attResp.validateRawAuthnrData();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;rawAuthnrData&quot;));
				});

				it(&quot;throws if missing&quot;, function() {
					attResp.authnrData.delete(&quot;rawAuthnrData&quot;);
					return assert.isRejected(attResp.validateRawAuthnrData(), Error, &quot;authnrData rawAuthnrData should be ArrayBuffer&quot;);
				});

				it(&quot;throws if not ArrayBuffer&quot;, function() {
					attResp.authnrData.set(&quot;rawAuthnrData&quot;, &quot;foo&quot;);
					return assert.isRejected(attResp.validateRawAuthnrData(), Error, &quot;authnrData rawAuthnrData should be ArrayBuffer&quot;);
				});
			});

			describe(&quot;validateAttestation&quot;, function() {
				it(&quot;accepts none&quot;, async function() {
					var ret = await attResp.validateAttestation();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;fmt&quot;));
				});

				it(&quot;throws on unknown fmt&quot;, function() {
					attResp.authnrData.set(&quot;fmt&quot;, &quot;asdf&quot;);
					return assert.isRejected(attResp.validateAttestation(), Error, &quot;no support for attestation format: asdf&quot;);
				});

				it(&quot;throws on undefined fmt&quot;, function() {
					attResp.authnrData.delete(&quot;fmt&quot;);
					return assert.isRejected(attResp.validateAttestation(), Error, &quot;expected &#039;fmt&#039; to be string, got: undefined&quot;);
				});
			});

			describe(&quot;validateRpIdHash&quot;, function() {
				after(() =&gt; {
					attResp.expectations.delete(&quot;rpId&quot;);
				});

				it(&quot;returns true when matches&quot;, async function() {
					var ret = await attResp.validateRpIdHash();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;rpIdHash&quot;));
				});

				it(&quot;throws when it doesn&#039;t match&quot;, function() {
					attResp.expectations.set(&quot;origin&quot;, &quot;https://google.com&quot;);
					return assert.isRejected(attResp.validateRpIdHash(), Error, &quot;authnrData rpIdHash mismatch&quot;);
				});

				it(&quot;throws when it doesn&#039;t match in case of invalid rpId&quot;, function() {
					attResp.expectations.set(&quot;origin&quot;, &quot;localhost&quot;);
					attResp.expectations.set(&quot;rpId&quot;, &quot;google.com&quot;);
					return assert.isRejected(attResp.validateRpIdHash(), Error, &quot;authnrData rpIdHash mismatch&quot;);
				});

				it(&quot;throws when length mismatches&quot;, function() {
					attResp.authnrData.set(&quot;rpIdHash&quot;, new Uint8Array([1, 2, 3]).buffer);
					return assert.isRejected(attResp.validateRpIdHash(), Error, &quot;authnrData rpIdHash length mismatch&quot;);
				});
			});

			describe(&quot;validateAaguid&quot;, function() {
				it(&quot;returns true on validation&quot;, async function() {
					var ret = await attResp.validateAaguid();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;aaguid&quot;));
				});

				it(&quot;throws if too short&quot;, function() {
					attResp.authnrData.set(&quot;aaguid&quot;, new Uint8Array([1, 2, 3]).buffer);
					return assert.isRejected(attResp.validateAaguid(), Error, &quot;authnrData AAGUID was wrong length&quot;);
				});
			});

			describe(&quot;validateCredId&quot;, function() {
				it(&quot;returns true when ArrayBuffer of correct length&quot;, async function() {
					var ret = await attResp.validateCredId();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;credId&quot;));
					assert.isTrue(attResp.audit.journal.has(&quot;credIdLen&quot;));
				});

				it(&quot;throws if length is undefined&quot;, function() {
					attResp.authnrData.delete(&quot;credIdLen&quot;);
					return assert.isRejected(attResp.validateCredId(), Error, &quot;authnrData credIdLen should be number, got undefined&quot;);
				});

				it(&quot;throws if length is not number&quot;, function() {
					attResp.authnrData.set(&quot;credIdLen&quot;, new Uint8Array());
					return assert.isRejected(attResp.validateCredId(), Error, &quot;authnrData credIdLen should be number, got object&quot;);
				});

				it(&quot;throws if length is wrong&quot;, function() {
					attResp.authnrData.set(&quot;credIdLen&quot;, 42);
					return assert.isRejected(attResp.validateCredId(), &quot;authnrData credId was wrong length&quot;);
				});

				it(&quot;throws if credId is undefined&quot;, function() {
					attResp.authnrData.delete(&quot;credId&quot;);
					return assert.isRejected(attResp.validateCredId(), &quot;authnrData credId should be ArrayBuffer&quot;);
				});

				it(&quot;throws if not array buffer&quot;, function() {
					attResp.authnrData.set(&quot;credId&quot;, &quot;foo&quot;);
					return assert.isRejected(attResp.validateCredId(), &quot;authnrData credId should be ArrayBuffer&quot;);
				});
			});

			describe(&quot;validatePublicKey&quot;, function() {
				it(&quot;returns true on validation&quot;, async function() {
					var ret = await attResp.validatePublicKey();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;credentialPublicKeyCose&quot;));
					assert.isTrue(attResp.audit.journal.has(&quot;credentialPublicKeyJwk&quot;));
					assert.isTrue(attResp.audit.journal.has(&quot;credentialPublicKeyPem&quot;));
				});
			});

			describe(&quot;validateTokenBinding&quot;, function() {
				it(&quot;returns true if tokenBinding is undefined&quot;, async function() {
					var ret = await attResp.validateTokenBinding();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;tokenBinding&quot;));
				});

				it(&quot;throws if tokenBinding is defined&quot;, function() {
					attResp.clientData.set(&quot;tokenBinding&quot;, &quot;foo&quot;);
					return assert.isRejected(attResp.validateTokenBinding(), Error, &quot;Token binding field malformed: foo&quot;);
				});
			});

			describe(&quot;validateFlags&quot;, function() {
				it(&quot;returns true on valid expectations&quot;, async function() {
					var ret = await attResp.validateFlags();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;flags&quot;));
				});

				it(&quot;throws on invalid expectations&quot;, function() {
					attResp.expectations.set(&quot;flags&quot;, [&quot;ED&quot;]);
					return assert.isRejected(attResp.validateFlags(), Error, &quot;expected flag was not set: ED&quot;);
				});

				it(&quot;throws if UV is set but UP is not set&quot;, function() {
					attResp.expectations.set(&quot;flags&quot;, [&quot;UV&quot;]);
					attResp.authnrData.set(&quot;flags&quot;, new Set([&quot;UV&quot;]));
					return assert.isRejected(attResp.validateFlags(), Error, &quot;expected User Presence (UP) flag to be set if User Verification (UV) is set&quot;);
				});

				it(&quot;throws if UV is not set&quot;, function() {
					attResp.expectations.set(&quot;flags&quot;, [&quot;UV&quot;]);
					attResp.authnrData.set(&quot;flags&quot;, new Set([&quot;ED&quot;]));
					return assert.isRejected(attResp.validateFlags(), Error, &quot;expected flag was not set: UV&quot;);
				});

				it(&quot;throws if UV but only UP is set&quot;, function() {
					attResp.expectations.set(&quot;flags&quot;, [&quot;UV&quot;]);
					attResp.authnrData.set(&quot;flags&quot;, new Set([&quot;UP&quot;]));
					return assert.isRejected(attResp.validateFlags(), Error, &quot;expected flag was not set: UV&quot;);
				});

				it(&quot;returns true on UP with UP-or-UV&quot;, async function() {
					attResp.expectations.set(&quot;flags&quot;, [&quot;UP-or-UV&quot;]);
					attResp.authnrData.set(&quot;flags&quot;, new Set([&quot;UP&quot;]));
					var ret = await attResp.validateFlags();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;flags&quot;));
				});

				it(&quot;returns true on UV with UP-or-UV&quot;, async function() {
					attResp.expectations.set(&quot;flags&quot;, [&quot;UP-or-UV&quot;]);
					attResp.authnrData.set(&quot;flags&quot;, new Set([&quot;UV&quot;, &quot;UP&quot;]));
					var ret = await attResp.validateFlags();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;flags&quot;));
				});

				it(&quot;throws if UP-or-UV and UV is set but not UP&quot;, function() {
					attResp.expectations.set(&quot;flags&quot;, [&quot;UP-or-UV&quot;]);
					attResp.authnrData.set(&quot;flags&quot;, new Set([&quot;UV&quot;]));
					return assert.isRejected(attResp.validateFlags(), Error, &quot;expected User Presence (UP) flag to be set if User Verification (UV) is set&quot;);
				});

				it(&quot;throws if UP-or-UV and neither is set&quot;, function() {
					attResp.expectations.set(&quot;flags&quot;, [&quot;UP-or-UV&quot;]);
					attResp.authnrData.set(&quot;flags&quot;, new Set([&quot;ED&quot;]));
					return assert.isRejected(attResp.validateFlags(), Error, &quot;expected User Presence (UP) or User Verification (UV) flag to be set and neither was&quot;);
				});

				it(&quot;throws if any of the RFU flags are set&quot;);
			});

			describe(&quot;validateInitialCounter&quot;, function() {
				it(&quot;returns true if valid&quot;, async function() {
					var ret = await attResp.validateInitialCounter();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.journal.has(&quot;counter&quot;));
				});

				it(&quot;throws if not a number&quot;, function() {
					attResp.authnrData.set(&quot;counter&quot;, &quot;foo&quot;);
					return assert.isRejected(attResp.validateInitialCounter(), Error, &quot;authnrData counter wasn&#039;t a number&quot;);
				});
			});

			describe(&quot;validateAudit for &#039;none&#039; attestation&quot;, function() {
				it(&quot;returns on all internal checks passed&quot;, async function() {
					await attResp.validateExpectations();
					await attResp.validateCreateRequest();
					// clientData validators
					await attResp.validateRawClientDataJson();
					await attResp.validateOrigin();
					await attResp.validateCreateType();
					await attResp.validateChallenge();
					await attResp.validateTokenBinding();
					await attResp.validateId();
					await attResp.validateTransports();
					// authnrData validators
					await attResp.validateRawAuthnrData();
					await attResp.validateAttestation();
					await attResp.validateRpIdHash();
					await attResp.validateAaguid();
					await attResp.validateCredId();
					await attResp.validatePublicKey();
					await attResp.validateFlags();
					await attResp.validateInitialCounter();

					// audit
					var ret = await attResp.validateAudit();
					assert.isTrue(ret);
					assert.isTrue(attResp.audit.complete);
				});

				it(&quot;throws on untested verifies&quot;, function() {
					return assert.isRejected(attResp.validateAudit(), Error, /^internal audit failed: .* was not validated$/);
				});

				it(&quot;throws on extra journal entries&quot;);

				it(&quot;throws on untested expectations&quot;);
				it(&quot;throws on untested request&quot;);
			});

			describe(&quot;validateAudit for assertion&quot;, function() {
				it(&quot;returns on all internal checks passed&quot;);
			});
		});
	});
});

describe(&quot;assertion validation&quot;, function() {
	var assnResp;
	beforeEach(function() {
		assnResp = {
			request: {},
			requiredExpectations: new Set([
				&quot;origin&quot;,
				&quot;challenge&quot;,
				&quot;flags&quot;,
				&quot;counter&quot;,
				&quot;publicKey&quot;,
			]),
			optionalExpectations: new Set([
				&quot;rpId&quot;,
				&quot;allowCredentials&quot;,
			]),
			expectations: new Map([
				[&quot;origin&quot;, &quot;https://localhost:8443&quot;],
				[&quot;challenge&quot;, &quot;33EHav-jZ1v9qwH783aU-j0ARx6r5o-YHh-wd7C6jPbd7Wh6ytbIZosIIACehwf9-s6hXhySHO-HHUjEwZS29w&quot;],
				[&quot;flags&quot;, [&quot;UP&quot;, &quot;AT&quot;]],
				[&quot;counter&quot;, 300],
				[&quot;publicKey&quot;, h.lib.assnPublicKey],
				[&quot;allowCredentials&quot;, [{
					id: h.lib.assertionResponse.rawId,
					type: &quot;public-key&quot;,
				}]],
			]),
			clientData: parser.parseClientResponse(h.lib.assertionResponse),
			authnrData: new Map([
				...parser.parseAuthnrAssertionResponse(h.lib.assertionResponse),
			]),
		};
		var testReq = cloneObject(h.lib.assertionResponse);
		testReq.rawId = h.lib.assertionResponse.rawId;
		testReq.response.clientDataJSON = h.lib.assertionResponse.response.clientDataJSON.slice(0);
		testReq.response.authenticatorData = h.lib.assertionResponse.response.authenticatorData.slice(0);
		testReq.response.signature = h.lib.assertionResponse.response.signature.slice(0);
		testReq.response.userHandle = h.lib.assertionResponse.response.userHandle.slice(0);
		assnResp.request = testReq;

		validator.attach(assnResp);
	});

	describe(&quot;validateUserHandle&quot;, function() {
		it(&quot;returns true when undefined&quot;, async function() {
			var ret = await assnResp.validateUserHandle();
			assert.isTrue(ret);
			assert.isTrue(assnResp.audit.journal.has(&quot;userHandle&quot;));
		});

		it(&quot;throws if not undefined&quot;, function() {
			assnResp.authnrData.set(&quot;userHandle&quot;, &quot;foo&quot;);
			return assert.isRejected(assnResp.validateUserHandle(), Error, &quot;unable to validate userHandle&quot;);
		});
	});

	describe(&quot;validateCounter&quot;, function() {
		it(&quot;returns true if counter has advanced&quot;, async function() {
			assert.strictEqual(assnResp.authnrData.get(&quot;counter&quot;), 363);
			assnResp.expectations.set(&quot;prevCounter&quot;, 362);
			var ret = await assnResp.validateCounter();
			assert.isTrue(ret);
			assert.isTrue(assnResp.audit.journal.has(&quot;counter&quot;));
			assert.equal(assnResp.audit.info.get(&quot;counter-supported&quot;), &quot;true&quot;);
		});

		it(&quot;returns true if counter is not supported but do not add it to journal&quot;, async function() {
			assnResp.authnrData.set(&quot;counter&quot;, 0);
			assnResp.expectations.set(&quot;prevCounter&quot;, 0);
			var ret = await assnResp.validateCounter();
			assert.isTrue(ret);
			assert.isTrue(assnResp.audit.journal.has(&quot;counter&quot;));
			assert.equal(assnResp.audit.info.get(&quot;counter-supported&quot;), &quot;false&quot;);
		});

		it(&quot;throws if counter is the same&quot;, function() {
			assert.strictEqual(assnResp.authnrData.get(&quot;counter&quot;), 363);
			assnResp.expectations.set(&quot;prevCounter&quot;, 363);
			return assert.isRejected(assnResp.validateCounter(), Error, &quot;counter rollback detected&quot;);
		});

		it(&quot;throws if counter has rolled back&quot;, function() {
			assert.strictEqual(assnResp.authnrData.get(&quot;counter&quot;), 363);
			assnResp.expectations.set(&quot;prevCounter&quot;, 364);
			return assert.isRejected(assnResp.validateCounter(), Error, &quot;counter rollback detected&quot;);
		});
	});

	describe(&quot;validateExpectations&quot;, function() {
		it(&quot;returns true on valid expectations&quot;, async function() {
			var ret = await assnResp.validateExpectations();
			assert.isTrue(ret);
			assert.isTrue(assnResp.audit.validExpectations);
		});
	});

	describe(&quot;validateId&quot;, function() {
		it(&quot;returns true on ArrayBuffer&quot;, async function() {
			var ret = await assnResp.validateId();
			assert.isTrue(ret);
			assert.isTrue(assnResp.audit.journal.has(&quot;rawId&quot;));
		});

		it(&quot;throws on non-ArrayBuffer&quot;, function() {
			assnResp.clientData.set(&quot;id&quot;, {});
			assnResp.clientData.set(&quot;rawId&quot;, {});
			return assert.isRejected(assnResp.validateId(), Error, &quot;expected id to be of type ArrayBuffer&quot;);
		});

		it(&quot;throws on undefined&quot;, function() {
			assnResp.clientData.set(&quot;id&quot;, undefined);
			assnResp.clientData.set(&quot;rawId&quot;, undefined);
			return assert.isRejected(assnResp.validateId(), Error, &quot;expected id to be of type ArrayBuffer&quot;);
		});


		it(&quot;throws on allowCredentials not includes rawId&quot;, function() {
			assnResp.expectations.set(&quot;allowCredentials&quot;, [{ type: &quot;public-key&quot;, id: coerceToArrayBuffer(&quot;dGVz&quot;, &quot;tes&quot;) }]);
			assnResp.clientData.set(&quot;rawId&quot;, coerceToArrayBuffer(&quot;Y2lhbw==&quot;, &quot;ciao&quot;));
			return assert.isRejected(assnResp.validateId(), Error, &quot;Credential ID does not match any value in allowCredentials&quot;);
		});
	});


	describe(&quot;validateAssertionSignature&quot;, function() {
		it(&quot;returns true on valid signature&quot;);
	});

	describe(&quot;validateAssertionResponse&quot;, function() {
		it(&quot;returns true if request is valid&quot;, async function() {
			var ret = await assnResp.validateAssertionResponse();
			assert.isTrue(ret);
			assert.isTrue(assnResp.audit.validRequest);
		});

		it(&quot;returns true for U2F request&quot;, async function() {
			var ret = await assnResp.validateAssertionResponse();
			assert.isTrue(ret);
			assert.isTrue(assnResp.audit.validRequest);
		});

		it(&quot;throws if request is undefined&quot;, function() {
			assnResp.request = undefined;
			assert.throws(() =&gt; {
				assnResp.validateAssertionResponse();
			}, TypeError, &quot;expected request to be Object, got undefined&quot;);
		});

		it(&quot;throws if response field is undefined&quot;, function() {
			delete assnResp.request.response;
			assert.throws(() =&gt; {
				assnResp.validateAssertionResponse();
			}, TypeError, &quot;expected &#039;response&#039; field of request to be Object, got undefined&quot;);
		});

		it(&quot;throws if response field is non-object&quot;, function() {
			assnResp.request.response = 3;
			assert.throws(() =&gt; {
				assnResp.validateAssertionResponse();
			}, TypeError, &quot;expected &#039;response&#039; field of request to be Object, got number&quot;);
		});

		it(&quot;throws if id field is undefined&quot;, function() {
			delete assnResp.request.id;
			delete assnResp.request.rawId;
			assert.throws(() =&gt; {
				assnResp.validateAssertionResponse();
			}, TypeError, &quot;expected &#039;id&#039; or &#039;rawId&#039; field of request to be ArrayBuffer, got rawId undefined and id undefined&quot;);
		});

		it(&quot;throws if rawId field is non-string&quot;, function() {
			assnResp.request.rawId = {};
			delete assnResp.request.id;
			assert.throws(() =&gt; {
				assnResp.validateAssertionResponse();
			}, TypeError, &quot;expected &#039;id&#039; or &#039;rawId&#039; field of request to be ArrayBuffer, got rawId object and id undefined&quot;);
		});

		it(&quot;throws if response.signature is undefined&quot;, function() {
			delete assnResp.request.response.signature;
			assert.throws(() =&gt; {
				assnResp.validateAssertionResponse();
			}, TypeError, &quot;expected &#039;response.signature&#039; to be base64 String or ArrayBuffer&quot;);
		});

		it(&quot;throws if response.signature is non-ArrayBuffer &amp; non-String&quot;, function() {
			assnResp.request.response.signature = {};
			assert.throws(() =&gt; {
				assnResp.validateAssertionResponse();
			}, TypeError, &quot;expected &#039;response.signature&#039; to be base64 String or ArrayBuffer&quot;);
		});

		it(&quot;passes with response.signature as ArrayBuffer&quot;, async function() {
			assnResp.request.response.signature = new ArrayBuffer();
			var ret = await assnResp.validateAssertionResponse();
			assert.isTrue(ret);
			assert.isTrue(assnResp.audit.validRequest);
		});

		it(&quot;passes with response.signature as String&quot;, async function() {
			assnResp.request.response.signature = &quot;&quot;;
			var ret = await assnResp.validateAssertionResponse();
			assert.isTrue(ret);
			assert.isTrue(assnResp.audit.validRequest);
		});

		it(&quot;throws if response.authenticatorData is undefined&quot;, function() {
			delete assnResp.request.response.authenticatorData;
			assert.throws(() =&gt; {
				assnResp.validateAssertionResponse();
			}, TypeError, &quot;expected &#039;response.authenticatorData&#039; to be base64 String or ArrayBuffer&quot;);
		});

		it(&quot;throws if response.authenticatorData is non-ArrayBuffer &amp; non-String&quot;, function() {
			assnResp.request.response.authenticatorData = {};
			assert.throws(() =&gt; {
				assnResp.validateAssertionResponse();
			}, TypeError, &quot;expected &#039;response.authenticatorData&#039; to be base64 String or ArrayBuffer&quot;);
		});

		it(&quot;passes with response.authenticatorData as ArrayBuffer&quot;, async function() {
			assnResp.request.response.authenticatorData = new ArrayBuffer();
			var ret = await assnResp.validateAssertionResponse();
			assert.isTrue(ret);
			assert.isTrue(assnResp.audit.validRequest);
		});

		it(&quot;passes with response.authenticatorData as String&quot;, async function() {
			assnResp.request.response.authenticatorData = &quot;&quot;;
			var ret = await assnResp.validateAssertionResponse();
			assert.isTrue(ret);
			assert.isTrue(assnResp.audit.validRequest);
		});

		it(&quot;returns true if response.userHandle is undefined&quot;, async function() {
			delete assnResp.request.response.userHandle;
			var ret = await assnResp.validateAssertionResponse();
			assert.isTrue(ret);
			assert.isTrue(assnResp.audit.validRequest);
		});

		it(&quot;throws if response.userHandle is non-ArrayBuffer &amp; non-String&quot;, function() {
			assnResp.request.response.userHandle = {};
			assert.throws(() =&gt; {
				assnResp.validateAssertionResponse();
			}, TypeError, &quot;expected &#039;response.userHandle&#039; to be base64 String, ArrayBuffer, or undefined&quot;);
		});

		it(&quot;passes with response.userHandle as ArrayBuffer&quot;, async function() {
			assnResp.request.response.userHandle = new ArrayBuffer();
			var ret = await assnResp.validateAssertionResponse();
			assert.isTrue(ret);
			assert.isTrue(assnResp.audit.validRequest);
		});

		it(&quot;passes with response.userHandle as String&quot;, async function() {
			assnResp.request.response.userHandle = &quot;&quot;;
			var ret = await assnResp.validateAssertionResponse();
			assert.isTrue(ret);
			assert.isTrue(assnResp.audit.validRequest);
		});

		it(&quot;throws if response.clientDataJSON is undefined&quot;, function() {
			delete assnResp.request.response.clientDataJSON;
			assert.throws(() =&gt; {
				assnResp.validateAssertionResponse();
			}, TypeError, &quot;expected &#039;response.clientDataJSON&#039; to be base64 String or ArrayBuffer&quot;);
		});

		it(&quot;throws if response.clientDataJSON is non-ArrayBuffer &amp; non-String&quot;, function() {
			assnResp.request.response.clientDataJSON = {};
			assert.throws(() =&gt; {
				assnResp.validateAssertionResponse();
			}, TypeError, &quot;expected &#039;response.clientDataJSON&#039; to be base64 String or ArrayBuffer&quot;);
		});

		it(&quot;passes with response.clientDataJSON as ArrayBuffer&quot;, async function() {
			assnResp.request.response.clientDataJSON = new ArrayBuffer();
			var ret = await assnResp.validateAssertionResponse();
			assert.isTrue(ret);
			assert.isTrue(assnResp.audit.validRequest);
		});

		it(&quot;passes with response.clientDataJSON as String&quot;, async function() {
			assnResp.request.response.clientDataJSON = &quot;&quot;;
			var ret = await assnResp.validateAssertionResponse();
			assert.isTrue(ret);
			assert.isTrue(assnResp.audit.validRequest);
		});
	});
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
