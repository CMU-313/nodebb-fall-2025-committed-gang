<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@fortawesome/fontawesome-free/js/fontawesome.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@fortawesome/fontawesome-free/js/fontawesome.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.48</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">3055</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">165.97</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">42.39</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */
(function () {
  &#039;use strict&#039;;

  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r] = t, e;
  }
  function _inherits(t, e) {
    if (&quot;function&quot; != typeof e &amp;&amp; null !== e) throw new TypeError(&quot;Super expression must either be null or a function&quot;);
    t.prototype = Object.create(e &amp;&amp; e.prototype, {
      constructor: {
        value: t,
        writable: !0,
        configurable: !0
      }
    }), Object.defineProperty(t, &quot;prototype&quot;, {
      writable: !1
    }), e &amp;&amp; _setPrototypeOf(t, e);
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r &amp;&amp; (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r &lt; arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
        _defineProperty(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
      return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
  }
  function _toPrimitive(t, r) {
    if (&quot;object&quot; != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || &quot;default&quot;);
      if (&quot;object&quot; != typeof i) return i;
      throw new TypeError(&quot;@@toPrimitive must return a primitive value.&quot;);
    }
    return (&quot;string&quot; === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, &quot;string&quot;);
    return &quot;symbol&quot; == typeof i ? i : i + &quot;&quot;;
  }
  function _wrapRegExp() {
    _wrapRegExp = function (e, r) {
      return new BabelRegExp(e, void 0, r);
    };
    var e = RegExp.prototype,
      r = new WeakMap();
    function BabelRegExp(e, t, p) {
      var o = RegExp(e, t);
      return r.set(o, p || r.get(e)), _setPrototypeOf(o, BabelRegExp.prototype);
    }
    function buildGroups(e, t) {
      var p = r.get(t);
      return Object.keys(p).reduce(function (r, t) {
        var o = p[t];
        if (&quot;number&quot; == typeof o) r[t] = e[o];else {
          for (var i = 0; void 0 === e[o[i]] &amp;&amp; i + 1 &lt; o.length;) i++;
          r[t] = e[o[i]];
        }
        return r;
      }, Object.create(null));
    }
    return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (r) {
      var t = e.exec.call(this, r);
      if (t) {
        t.groups = buildGroups(t, this);
        var p = t.indices;
        p &amp;&amp; (p.groups = buildGroups(p, this));
      }
      return t;
    }, BabelRegExp.prototype[Symbol.replace] = function (t, p) {
      if (&quot;string&quot; == typeof p) {
        var o = r.get(this);
        return e[Symbol.replace].call(this, t, p.replace(/\$&lt;([^&gt;]+)&gt;/g, function (e, r) {
          var t = o[r];
          return &quot;$&quot; + (Array.isArray(t) ? t.join(&quot;$&quot;) : t);
        }));
      }
      if (&quot;function&quot; == typeof p) {
        var i = this;
        return e[Symbol.replace].call(this, t, function () {
          var e = arguments;
          return &quot;object&quot; != typeof e[e.length - 1] &amp;&amp; (e = [].slice.call(e)).push(buildGroups(e, i)), p.apply(this, e);
        });
      }
      return e[Symbol.replace].call(this, t, p);
    }, _wrapRegExp.apply(this, arguments);
  }

  const noop = () =&gt; {};
  let _WINDOW = {};
  let _DOCUMENT = {};
  let _MUTATION_OBSERVER = null;
  let _PERFORMANCE = {
    mark: noop,
    measure: noop
  };
  try {
    if (typeof window !== &#039;undefined&#039;) _WINDOW = window;
    if (typeof document !== &#039;undefined&#039;) _DOCUMENT = document;
    if (typeof MutationObserver !== &#039;undefined&#039;) _MUTATION_OBSERVER = MutationObserver;
    if (typeof performance !== &#039;undefined&#039;) _PERFORMANCE = performance;
  } catch (e) {}
  const {
    userAgent = &#039;&#039;
  } = _WINDOW.navigator || {};
  const WINDOW = _WINDOW;
  const DOCUMENT = _DOCUMENT;
  const MUTATION_OBSERVER = _MUTATION_OBSERVER;
  const PERFORMANCE = _PERFORMANCE;
  const IS_BROWSER = !!WINDOW.document;
  const IS_DOM = !!DOCUMENT.documentElement &amp;&amp; !!DOCUMENT.head &amp;&amp; typeof DOCUMENT.addEventListener === &#039;function&#039; &amp;&amp; typeof DOCUMENT.createElement === &#039;function&#039;;
  const IS_IE = ~userAgent.indexOf(&#039;MSIE&#039;) || ~userAgent.indexOf(&#039;Trident/&#039;);

  var p = /fa(s|r|l|t|d|dr|dl|dt|b|k|kd|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/,
    g = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i;
  var S = {
      classic: {
        fa: &quot;solid&quot;,
        fas: &quot;solid&quot;,
        &quot;fa-solid&quot;: &quot;solid&quot;,
        far: &quot;regular&quot;,
        &quot;fa-regular&quot;: &quot;regular&quot;,
        fal: &quot;light&quot;,
        &quot;fa-light&quot;: &quot;light&quot;,
        fat: &quot;thin&quot;,
        &quot;fa-thin&quot;: &quot;thin&quot;,
        fab: &quot;brands&quot;,
        &quot;fa-brands&quot;: &quot;brands&quot;
      },
      duotone: {
        fa: &quot;solid&quot;,
        fad: &quot;solid&quot;,
        &quot;fa-solid&quot;: &quot;solid&quot;,
        &quot;fa-duotone&quot;: &quot;solid&quot;,
        fadr: &quot;regular&quot;,
        &quot;fa-regular&quot;: &quot;regular&quot;,
        fadl: &quot;light&quot;,
        &quot;fa-light&quot;: &quot;light&quot;,
        fadt: &quot;thin&quot;,
        &quot;fa-thin&quot;: &quot;thin&quot;
      },
      sharp: {
        fa: &quot;solid&quot;,
        fass: &quot;solid&quot;,
        &quot;fa-solid&quot;: &quot;solid&quot;,
        fasr: &quot;regular&quot;,
        &quot;fa-regular&quot;: &quot;regular&quot;,
        fasl: &quot;light&quot;,
        &quot;fa-light&quot;: &quot;light&quot;,
        fast: &quot;thin&quot;,
        &quot;fa-thin&quot;: &quot;thin&quot;
      },
      &quot;sharp-duotone&quot;: {
        fa: &quot;solid&quot;,
        fasds: &quot;solid&quot;,
        &quot;fa-solid&quot;: &quot;solid&quot;,
        fasdr: &quot;regular&quot;,
        &quot;fa-regular&quot;: &quot;regular&quot;,
        fasdl: &quot;light&quot;,
        &quot;fa-light&quot;: &quot;light&quot;,
        fasdt: &quot;thin&quot;,
        &quot;fa-thin&quot;: &quot;thin&quot;
      }
    },
    A = {
      GROUP: &quot;duotone-group&quot;,
      SWAP_OPACITY: &quot;swap-opacity&quot;,
      PRIMARY: &quot;primary&quot;,
      SECONDARY: &quot;secondary&quot;
    },
    P = [&quot;fa-classic&quot;, &quot;fa-duotone&quot;, &quot;fa-sharp&quot;, &quot;fa-sharp-duotone&quot;];
  var s = &quot;classic&quot;,
    t = &quot;duotone&quot;,
    r = &quot;sharp&quot;,
    o = &quot;sharp-duotone&quot;,
    L = [s, t, r, o];
  var G = {
      classic: {
        900: &quot;fas&quot;,
        400: &quot;far&quot;,
        normal: &quot;far&quot;,
        300: &quot;fal&quot;,
        100: &quot;fat&quot;
      },
      duotone: {
        900: &quot;fad&quot;,
        400: &quot;fadr&quot;,
        300: &quot;fadl&quot;,
        100: &quot;fadt&quot;
      },
      sharp: {
        900: &quot;fass&quot;,
        400: &quot;fasr&quot;,
        300: &quot;fasl&quot;,
        100: &quot;fast&quot;
      },
      &quot;sharp-duotone&quot;: {
        900: &quot;fasds&quot;,
        400: &quot;fasdr&quot;,
        300: &quot;fasdl&quot;,
        100: &quot;fasdt&quot;
      }
    };
  var lt = {
      &quot;Font Awesome 6 Free&quot;: {
        900: &quot;fas&quot;,
        400: &quot;far&quot;
      },
      &quot;Font Awesome 6 Pro&quot;: {
        900: &quot;fas&quot;,
        400: &quot;far&quot;,
        normal: &quot;far&quot;,
        300: &quot;fal&quot;,
        100: &quot;fat&quot;
      },
      &quot;Font Awesome 6 Brands&quot;: {
        400: &quot;fab&quot;,
        normal: &quot;fab&quot;
      },
      &quot;Font Awesome 6 Duotone&quot;: {
        900: &quot;fad&quot;,
        400: &quot;fadr&quot;,
        normal: &quot;fadr&quot;,
        300: &quot;fadl&quot;,
        100: &quot;fadt&quot;
      },
      &quot;Font Awesome 6 Sharp&quot;: {
        900: &quot;fass&quot;,
        400: &quot;fasr&quot;,
        normal: &quot;fasr&quot;,
        300: &quot;fasl&quot;,
        100: &quot;fast&quot;
      },
      &quot;Font Awesome 6 Sharp Duotone&quot;: {
        900: &quot;fasds&quot;,
        400: &quot;fasdr&quot;,
        normal: &quot;fasdr&quot;,
        300: &quot;fasdl&quot;,
        100: &quot;fasdt&quot;
      }
    };
  var pt = new Map([[&quot;classic&quot;, {
      defaultShortPrefixId: &quot;fas&quot;,
      defaultStyleId: &quot;solid&quot;,
      styleIds: [&quot;solid&quot;, &quot;regular&quot;, &quot;light&quot;, &quot;thin&quot;, &quot;brands&quot;],
      futureStyleIds: [],
      defaultFontWeight: 900
    }], [&quot;sharp&quot;, {
      defaultShortPrefixId: &quot;fass&quot;,
      defaultStyleId: &quot;solid&quot;,
      styleIds: [&quot;solid&quot;, &quot;regular&quot;, &quot;light&quot;, &quot;thin&quot;],
      futureStyleIds: [],
      defaultFontWeight: 900
    }], [&quot;duotone&quot;, {
      defaultShortPrefixId: &quot;fad&quot;,
      defaultStyleId: &quot;solid&quot;,
      styleIds: [&quot;solid&quot;, &quot;regular&quot;, &quot;light&quot;, &quot;thin&quot;],
      futureStyleIds: [],
      defaultFontWeight: 900
    }], [&quot;sharp-duotone&quot;, {
      defaultShortPrefixId: &quot;fasds&quot;,
      defaultStyleId: &quot;solid&quot;,
      styleIds: [&quot;solid&quot;, &quot;regular&quot;, &quot;light&quot;, &quot;thin&quot;],
      futureStyleIds: [],
      defaultFontWeight: 900
    }]]),
    xt = {
      classic: {
        solid: &quot;fas&quot;,
        regular: &quot;far&quot;,
        light: &quot;fal&quot;,
        thin: &quot;fat&quot;,
        brands: &quot;fab&quot;
      },
      duotone: {
        solid: &quot;fad&quot;,
        regular: &quot;fadr&quot;,
        light: &quot;fadl&quot;,
        thin: &quot;fadt&quot;
      },
      sharp: {
        solid: &quot;fass&quot;,
        regular: &quot;fasr&quot;,
        light: &quot;fasl&quot;,
        thin: &quot;fast&quot;
      },
      &quot;sharp-duotone&quot;: {
        solid: &quot;fasds&quot;,
        regular: &quot;fasdr&quot;,
        light: &quot;fasdl&quot;,
        thin: &quot;fasdt&quot;
      }
    };
  var Ft = [&quot;fak&quot;, &quot;fa-kit&quot;, &quot;fakd&quot;, &quot;fa-kit-duotone&quot;],
    St = {
      kit: {
        fak: &quot;kit&quot;,
        &quot;fa-kit&quot;: &quot;kit&quot;
      },
      &quot;kit-duotone&quot;: {
        fakd: &quot;kit-duotone&quot;,
        &quot;fa-kit-duotone&quot;: &quot;kit-duotone&quot;
      }
    },
    At = [&quot;kit&quot;];
  var Ct = {
    kit: {
      &quot;fa-kit&quot;: &quot;fak&quot;
    },
    &quot;kit-duotone&quot;: {
      &quot;fa-kit-duotone&quot;: &quot;fakd&quot;
    }
  };
  var Lt = [&quot;fak&quot;, &quot;fakd&quot;],
    Wt = {
      kit: {
        fak: &quot;fa-kit&quot;
      },
      &quot;kit-duotone&quot;: {
        fakd: &quot;fa-kit-duotone&quot;
      }
    };
  var Et = {
      kit: {
        kit: &quot;fak&quot;
      },
      &quot;kit-duotone&quot;: {
        &quot;kit-duotone&quot;: &quot;fakd&quot;
      }
    };

  var t$1 = {
      GROUP: &quot;duotone-group&quot;,
      SWAP_OPACITY: &quot;swap-opacity&quot;,
      PRIMARY: &quot;primary&quot;,
      SECONDARY: &quot;secondary&quot;
    },
    r$1 = [&quot;fa-classic&quot;, &quot;fa-duotone&quot;, &quot;fa-sharp&quot;, &quot;fa-sharp-duotone&quot;];
  var bt$1 = [&quot;fak&quot;, &quot;fa-kit&quot;, &quot;fakd&quot;, &quot;fa-kit-duotone&quot;];
  var Yt = {
      &quot;Font Awesome Kit&quot;: {
        400: &quot;fak&quot;,
        normal: &quot;fak&quot;
      },
      &quot;Font Awesome Kit Duotone&quot;: {
        400: &quot;fakd&quot;,
        normal: &quot;fakd&quot;
      }
    };
  var ua = {
      classic: {
        &quot;fa-brands&quot;: &quot;fab&quot;,
        &quot;fa-duotone&quot;: &quot;fad&quot;,
        &quot;fa-light&quot;: &quot;fal&quot;,
        &quot;fa-regular&quot;: &quot;far&quot;,
        &quot;fa-solid&quot;: &quot;fas&quot;,
        &quot;fa-thin&quot;: &quot;fat&quot;
      },
      duotone: {
        &quot;fa-regular&quot;: &quot;fadr&quot;,
        &quot;fa-light&quot;: &quot;fadl&quot;,
        &quot;fa-thin&quot;: &quot;fadt&quot;
      },
      sharp: {
        &quot;fa-solid&quot;: &quot;fass&quot;,
        &quot;fa-regular&quot;: &quot;fasr&quot;,
        &quot;fa-light&quot;: &quot;fasl&quot;,
        &quot;fa-thin&quot;: &quot;fast&quot;
      },
      &quot;sharp-duotone&quot;: {
        &quot;fa-solid&quot;: &quot;fasds&quot;,
        &quot;fa-regular&quot;: &quot;fasdr&quot;,
        &quot;fa-light&quot;: &quot;fasdl&quot;,
        &quot;fa-thin&quot;: &quot;fasdt&quot;
      }
    },
    I$1 = {
      classic: [&quot;fas&quot;, &quot;far&quot;, &quot;fal&quot;, &quot;fat&quot;, &quot;fad&quot;],
      duotone: [&quot;fadr&quot;, &quot;fadl&quot;, &quot;fadt&quot;],
      sharp: [&quot;fass&quot;, &quot;fasr&quot;, &quot;fasl&quot;, &quot;fast&quot;],
      &quot;sharp-duotone&quot;: [&quot;fasds&quot;, &quot;fasdr&quot;, &quot;fasdl&quot;, &quot;fasdt&quot;]
    },
    ga = {
      classic: {
        fab: &quot;fa-brands&quot;,
        fad: &quot;fa-duotone&quot;,
        fal: &quot;fa-light&quot;,
        far: &quot;fa-regular&quot;,
        fas: &quot;fa-solid&quot;,
        fat: &quot;fa-thin&quot;
      },
      duotone: {
        fadr: &quot;fa-regular&quot;,
        fadl: &quot;fa-light&quot;,
        fadt: &quot;fa-thin&quot;
      },
      sharp: {
        fass: &quot;fa-solid&quot;,
        fasr: &quot;fa-regular&quot;,
        fasl: &quot;fa-light&quot;,
        fast: &quot;fa-thin&quot;
      },
      &quot;sharp-duotone&quot;: {
        fasds: &quot;fa-solid&quot;,
        fasdr: &quot;fa-regular&quot;,
        fasdl: &quot;fa-light&quot;,
        fasdt: &quot;fa-thin&quot;
      }
    },
    x = [&quot;fa-solid&quot;, &quot;fa-regular&quot;, &quot;fa-light&quot;, &quot;fa-thin&quot;, &quot;fa-duotone&quot;, &quot;fa-brands&quot;],
    Ia = [&quot;fa&quot;, &quot;fas&quot;, &quot;far&quot;, &quot;fal&quot;, &quot;fat&quot;, &quot;fad&quot;, &quot;fadr&quot;, &quot;fadl&quot;, &quot;fadt&quot;, &quot;fab&quot;, &quot;fass&quot;, &quot;fasr&quot;, &quot;fasl&quot;, &quot;fast&quot;, &quot;fasds&quot;, &quot;fasdr&quot;, &quot;fasdl&quot;, &quot;fasdt&quot;, ...r$1, ...x],
    m$1 = [&quot;solid&quot;, &quot;regular&quot;, &quot;light&quot;, &quot;thin&quot;, &quot;duotone&quot;, &quot;brands&quot;],
    c$1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    F$1 = c$1.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]),
    ma = [...Object.keys(I$1), ...m$1, &quot;2xs&quot;, &quot;xs&quot;, &quot;sm&quot;, &quot;lg&quot;, &quot;xl&quot;, &quot;2xl&quot;, &quot;beat&quot;, &quot;border&quot;, &quot;fade&quot;, &quot;beat-fade&quot;, &quot;bounce&quot;, &quot;flip-both&quot;, &quot;flip-horizontal&quot;, &quot;flip-vertical&quot;, &quot;flip&quot;, &quot;fw&quot;, &quot;inverse&quot;, &quot;layers-counter&quot;, &quot;layers-text&quot;, &quot;layers&quot;, &quot;li&quot;, &quot;pull-left&quot;, &quot;pull-right&quot;, &quot;pulse&quot;, &quot;rotate-180&quot;, &quot;rotate-270&quot;, &quot;rotate-90&quot;, &quot;rotate-by&quot;, &quot;shake&quot;, &quot;spin-pulse&quot;, &quot;spin-reverse&quot;, &quot;spin&quot;, &quot;stack-1x&quot;, &quot;stack-2x&quot;, &quot;stack&quot;, &quot;ul&quot;, t$1.GROUP, t$1.SWAP_OPACITY, t$1.PRIMARY, t$1.SECONDARY].concat(c$1.map(a =&gt; &quot;&quot;.concat(a, &quot;x&quot;))).concat(F$1.map(a =&gt; &quot;w-&quot;.concat(a)));
  var wa = {
      &quot;Font Awesome 5 Free&quot;: {
        900: &quot;fas&quot;,
        400: &quot;far&quot;
      },
      &quot;Font Awesome 5 Pro&quot;: {
        900: &quot;fas&quot;,
        400: &quot;far&quot;,
        normal: &quot;far&quot;,
        300: &quot;fal&quot;
      },
      &quot;Font Awesome 5 Brands&quot;: {
        400: &quot;fab&quot;,
        normal: &quot;fab&quot;
      },
      &quot;Font Awesome 5 Duotone&quot;: {
        900: &quot;fad&quot;
      }
    };

  const NAMESPACE_IDENTIFIER = &#039;___FONT_AWESOME___&#039;;
  const UNITS_IN_GRID = 16;
  const DEFAULT_CSS_PREFIX = &#039;fa&#039;;
  const DEFAULT_REPLACEMENT_CLASS = &#039;svg-inline--fa&#039;;
  const DATA_FA_I2SVG = &#039;data-fa-i2svg&#039;;
  const DATA_FA_PSEUDO_ELEMENT = &#039;data-fa-pseudo-element&#039;;
  const DATA_FA_PSEUDO_ELEMENT_PENDING = &#039;data-fa-pseudo-element-pending&#039;;
  const DATA_PREFIX = &#039;data-prefix&#039;;
  const DATA_ICON = &#039;data-icon&#039;;
  const HTML_CLASS_I2SVG_BASE_CLASS = &#039;fontawesome-i2svg&#039;;
  const MUTATION_APPROACH_ASYNC = &#039;async&#039;;
  const TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS = [&#039;HTML&#039;, &#039;HEAD&#039;, &#039;STYLE&#039;, &#039;SCRIPT&#039;];
  const PRODUCTION = (() =&gt; {
    try {
      return &quot;production&quot; === &#039;production&#039;;
    } catch (e$$1) {
      return false;
    }
  })();
  function familyProxy(obj) {
    // Defaults to the classic family if family is not available
    return new Proxy(obj, {
      get(target, prop) {
        return prop in target ? target[prop] : target[s];
      }
    });
  }
  const _PREFIX_TO_STYLE = _objectSpread2({}, S);

  // We changed FACSSClassesToStyleId in the icons repo to be canonical and as such, &quot;classic&quot; family does not have any
  // duotone styles.  But we do still need duotone in _PREFIX_TO_STYLE below, so we are manually adding
  // {&#039;fa-duotone&#039;: &#039;duotone&#039;}
  _PREFIX_TO_STYLE[s] = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, {
    &#039;fa-duotone&#039;: &#039;duotone&#039;
  }), S[s]), St[&#039;kit&#039;]), St[&#039;kit-duotone&#039;]);
  const PREFIX_TO_STYLE = familyProxy(_PREFIX_TO_STYLE);
  const _STYLE_TO_PREFIX = _objectSpread2({}, xt);

  // We changed FAStyleIdToShortPrefixId in the icons repo to be canonical and as such, &quot;classic&quot; family does not have any
  // duotone styles.  But we do still need duotone in _STYLE_TO_PREFIX below, so we are manually adding {duotone: &#039;fad&#039;}
  _STYLE_TO_PREFIX[s] = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, {
    duotone: &#039;fad&#039;
  }), _STYLE_TO_PREFIX[s]), Et[&#039;kit&#039;]), Et[&#039;kit-duotone&#039;]);
  const STYLE_TO_PREFIX = familyProxy(_STYLE_TO_PREFIX);
  const _PREFIX_TO_LONG_STYLE = _objectSpread2({}, ga);
  _PREFIX_TO_LONG_STYLE[s] = _objectSpread2(_objectSpread2({}, _PREFIX_TO_LONG_STYLE[s]), Wt[&#039;kit&#039;]);
  const PREFIX_TO_LONG_STYLE = familyProxy(_PREFIX_TO_LONG_STYLE);
  const _LONG_STYLE_TO_PREFIX = _objectSpread2({}, ua);
  _LONG_STYLE_TO_PREFIX[s] = _objectSpread2(_objectSpread2({}, _LONG_STYLE_TO_PREFIX[s]), Ct[&#039;kit&#039;]);
  const LONG_STYLE_TO_PREFIX = familyProxy(_LONG_STYLE_TO_PREFIX);
  const ICON_SELECTION_SYNTAX_PATTERN = p; // eslint-disable-line no-useless-escape

  const LAYERS_TEXT_CLASSNAME = &#039;fa-layers-text&#039;;
  const FONT_FAMILY_PATTERN = g;
  const _FONT_WEIGHT_TO_PREFIX = _objectSpread2({}, G);
  const FONT_WEIGHT_TO_PREFIX = familyProxy(_FONT_WEIGHT_TO_PREFIX);
  const ATTRIBUTES_WATCHED_FOR_MUTATION = [&#039;class&#039;, &#039;data-prefix&#039;, &#039;data-icon&#039;, &#039;data-fa-transform&#039;, &#039;data-fa-mask&#039;];
  const DUOTONE_CLASSES = A;
  const RESERVED_CLASSES = [...At, ...ma];

  const initial = WINDOW.FontAwesomeConfig || {};
  function getAttrConfig(attr) {
    var element = DOCUMENT.querySelector(&#039;script[&#039; + attr + &#039;]&#039;);
    if (element) {
      return element.getAttribute(attr);
    }
  }
  function coerce(val) {
    // Getting an empty string will occur if the attribute is set on the HTML tag but without a value
    // We&#039;ll assume that this is an indication that it should be toggled to true
    if (val === &#039;&#039;) return true;
    if (val === &#039;false&#039;) return false;
    if (val === &#039;true&#039;) return true;
    return val;
  }
  if (DOCUMENT &amp;&amp; typeof DOCUMENT.querySelector === &#039;function&#039;) {
    const attrs = [[&#039;data-family-prefix&#039;, &#039;familyPrefix&#039;], [&#039;data-css-prefix&#039;, &#039;cssPrefix&#039;], [&#039;data-family-default&#039;, &#039;familyDefault&#039;], [&#039;data-style-default&#039;, &#039;styleDefault&#039;], [&#039;data-replacement-class&#039;, &#039;replacementClass&#039;], [&#039;data-auto-replace-svg&#039;, &#039;autoReplaceSvg&#039;], [&#039;data-auto-add-css&#039;, &#039;autoAddCss&#039;], [&#039;data-auto-a11y&#039;, &#039;autoA11y&#039;], [&#039;data-search-pseudo-elements&#039;, &#039;searchPseudoElements&#039;], [&#039;data-observe-mutations&#039;, &#039;observeMutations&#039;], [&#039;data-mutate-approach&#039;, &#039;mutateApproach&#039;], [&#039;data-keep-original-source&#039;, &#039;keepOriginalSource&#039;], [&#039;data-measure-performance&#039;, &#039;measurePerformance&#039;], [&#039;data-show-missing-icons&#039;, &#039;showMissingIcons&#039;]];
    attrs.forEach(_ref =&gt; {
      let [attr, key] = _ref;
      const val = coerce(getAttrConfig(attr));
      if (val !== undefined &amp;&amp; val !== null) {
        initial[key] = val;
      }
    });
  }
  const _default = {
    styleDefault: &#039;solid&#039;,
    familyDefault: s,
    cssPrefix: DEFAULT_CSS_PREFIX,
    replacementClass: DEFAULT_REPLACEMENT_CLASS,
    autoReplaceSvg: true,
    autoAddCss: true,
    autoA11y: true,
    searchPseudoElements: false,
    observeMutations: true,
    mutateApproach: &#039;async&#039;,
    keepOriginalSource: true,
    measurePerformance: false,
    showMissingIcons: true
  };

  // familyPrefix is deprecated but we must still support it if present
  if (initial.familyPrefix) {
    initial.cssPrefix = initial.familyPrefix;
  }
  const _config = _objectSpread2(_objectSpread2({}, _default), initial);
  if (!_config.autoReplaceSvg) _config.observeMutations = false;
  const config = {};
  Object.keys(_default).forEach(key =&gt; {
    Object.defineProperty(config, key, {
      enumerable: true,
      set: function (val) {
        _config[key] = val;
        _onChangeCb.forEach(cb =&gt; cb(config));
      },
      get: function () {
        return _config[key];
      }
    });
  });

  // familyPrefix is deprecated as of 6.2.0 and should be removed in 7.0.0
  Object.defineProperty(config, &#039;familyPrefix&#039;, {
    enumerable: true,
    set: function (val) {
      _config.cssPrefix = val;
      _onChangeCb.forEach(cb =&gt; cb(config));
    },
    get: function () {
      return _config.cssPrefix;
    }
  });
  WINDOW.FontAwesomeConfig = config;
  const _onChangeCb = [];
  function onChange(cb) {
    _onChangeCb.push(cb);
    return () =&gt; {
      _onChangeCb.splice(_onChangeCb.indexOf(cb), 1);
    };
  }

  const d$2 = UNITS_IN_GRID;
  const meaninglessTransform = {
    size: 16,
    x: 0,
    y: 0,
    rotate: 0,
    flipX: false,
    flipY: false
  };
  function bunker(fn) {
    try {
      for (var _len = arguments.length, args = new Array(_len &gt; 1 ? _len - 1 : 0), _key = 1; _key &lt; _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      fn(...args);
    } catch (e) {
      if (!PRODUCTION) {
        throw e;
      }
    }
  }
  function insertCss(css) {
    if (!css || !IS_DOM) {
      return;
    }
    const style = DOCUMENT.createElement(&#039;style&#039;);
    style.setAttribute(&#039;type&#039;, &#039;text/css&#039;);
    style.innerHTML = css;
    const headChildren = DOCUMENT.head.childNodes;
    let beforeChild = null;
    for (let i = headChildren.length - 1; i &gt; -1; i--) {
      const child = headChildren[i];
      const tagName = (child.tagName || &#039;&#039;).toUpperCase();
      if ([&#039;STYLE&#039;, &#039;LINK&#039;].indexOf(tagName) &gt; -1) {
        beforeChild = child;
      }
    }
    DOCUMENT.head.insertBefore(style, beforeChild);
    return css;
  }
  const idPool = &#039;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#039;;
  function nextUniqueId() {
    let size = 12;
    let id = &#039;&#039;;
    while (size-- &gt; 0) {
      id += idPool[Math.random() * 62 | 0];
    }
    return id;
  }
  function toArray(obj) {
    const array = [];
    for (let i = (obj || []).length &gt;&gt;&gt; 0; i--;) {
      array[i] = obj[i];
    }
    return array;
  }
  function classArray(node) {
    if (node.classList) {
      return toArray(node.classList);
    } else {
      return (node.getAttribute(&#039;class&#039;) || &#039;&#039;).split(&#039; &#039;).filter(i =&gt; i);
    }
  }
  function htmlEscape(str) {
    return &quot;&quot;.concat(str).replace(/&amp;/g, &#039;&amp;amp;&#039;).replace(/&quot;/g, &#039;&amp;quot;&#039;).replace(/&#039;/g, &#039;&amp;#39;&#039;).replace(/&lt;/g, &#039;&amp;lt;&#039;).replace(/&gt;/g, &#039;&amp;gt;&#039;);
  }
  function joinAttributes(attributes) {
    return Object.keys(attributes || {}).reduce((acc, attributeName) =&gt; {
      return acc + &quot;&quot;.concat(attributeName, &quot;=\&quot;&quot;).concat(htmlEscape(attributes[attributeName]), &quot;\&quot; &quot;);
    }, &#039;&#039;).trim();
  }
  function joinStyles(styles) {
    return Object.keys(styles || {}).reduce((acc, styleName) =&gt; {
      return acc + &quot;&quot;.concat(styleName, &quot;: &quot;).concat(styles[styleName].trim(), &quot;;&quot;);
    }, &#039;&#039;);
  }
  function transformIsMeaningful(transform) {
    return transform.size !== meaninglessTransform.size || transform.x !== meaninglessTransform.x || transform.y !== meaninglessTransform.y || transform.rotate !== meaninglessTransform.rotate || transform.flipX || transform.flipY;
  }
  function transformForSvg(_ref) {
    let {
      transform,
      containerWidth,
      iconWidth
    } = _ref;
    const outer = {
      transform: &quot;translate(&quot;.concat(containerWidth / 2, &quot; 256)&quot;)
    };
    const innerTranslate = &quot;translate(&quot;.concat(transform.x * 32, &quot;, &quot;).concat(transform.y * 32, &quot;) &quot;);
    const innerScale = &quot;scale(&quot;.concat(transform.size / 16 * (transform.flipX ? -1 : 1), &quot;, &quot;).concat(transform.size / 16 * (transform.flipY ? -1 : 1), &quot;) &quot;);
    const innerRotate = &quot;rotate(&quot;.concat(transform.rotate, &quot; 0 0)&quot;);
    const inner = {
      transform: &quot;&quot;.concat(innerTranslate, &quot; &quot;).concat(innerScale, &quot; &quot;).concat(innerRotate)
    };
    const path = {
      transform: &quot;translate(&quot;.concat(iconWidth / 2 * -1, &quot; -256)&quot;)
    };
    return {
      outer,
      inner,
      path
    };
  }
  function transformForCss(_ref2) {
    let {
      transform,
      width = UNITS_IN_GRID,
      height = UNITS_IN_GRID,
      startCentered = false
    } = _ref2;
    let val = &#039;&#039;;
    if (startCentered &amp;&amp; IS_IE) {
      val += &quot;translate(&quot;.concat(transform.x / d$2 - width / 2, &quot;em, &quot;).concat(transform.y / d$2 - height / 2, &quot;em) &quot;);
    } else if (startCentered) {
      val += &quot;translate(calc(-50% + &quot;.concat(transform.x / d$2, &quot;em), calc(-50% + &quot;).concat(transform.y / d$2, &quot;em)) &quot;);
    } else {
      val += &quot;translate(&quot;.concat(transform.x / d$2, &quot;em, &quot;).concat(transform.y / d$2, &quot;em) &quot;);
    }
    val += &quot;scale(&quot;.concat(transform.size / d$2 * (transform.flipX ? -1 : 1), &quot;, &quot;).concat(transform.size / d$2 * (transform.flipY ? -1 : 1), &quot;) &quot;);
    val += &quot;rotate(&quot;.concat(transform.rotate, &quot;deg) &quot;);
    return val;
  }

  var baseStyles = &quot;:host,:root{--fa-font-solid:normal 900 1em/1 \&quot;Font Awesome 6 Free\&quot;;--fa-font-regular:normal 400 1em/1 \&quot;Font Awesome 6 Free\&quot;;--fa-font-light:normal 300 1em/1 \&quot;Font Awesome 6 Pro\&quot;;--fa-font-thin:normal 100 1em/1 \&quot;Font Awesome 6 Pro\&quot;;--fa-font-duotone:normal 900 1em/1 \&quot;Font Awesome 6 Duotone\&quot;;--fa-font-duotone-regular:normal 400 1em/1 \&quot;Font Awesome 6 Duotone\&quot;;--fa-font-duotone-light:normal 300 1em/1 \&quot;Font Awesome 6 Duotone\&quot;;--fa-font-duotone-thin:normal 100 1em/1 \&quot;Font Awesome 6 Duotone\&quot;;--fa-font-brands:normal 400 1em/1 \&quot;Font Awesome 6 Brands\&quot;;--fa-font-sharp-solid:normal 900 1em/1 \&quot;Font Awesome 6 Sharp\&quot;;--fa-font-sharp-regular:normal 400 1em/1 \&quot;Font Awesome 6 Sharp\&quot;;--fa-font-sharp-light:normal 300 1em/1 \&quot;Font Awesome 6 Sharp\&quot;;--fa-font-sharp-thin:normal 100 1em/1 \&quot;Font Awesome 6 Sharp\&quot;;--fa-font-sharp-duotone-solid:normal 900 1em/1 \&quot;Font Awesome 6 Sharp Duotone\&quot;;--fa-font-sharp-duotone-regular:normal 400 1em/1 \&quot;Font Awesome 6 Sharp Duotone\&quot;;--fa-font-sharp-duotone-light:normal 300 1em/1 \&quot;Font Awesome 6 Sharp Duotone\&quot;;--fa-font-sharp-duotone-thin:normal 100 1em/1 \&quot;Font Awesome 6 Sharp Duotone\&quot;}svg:not(:host).svg-inline--fa,svg:not(:root).svg-inline--fa{overflow:visible;box-sizing:content-box}.svg-inline--fa{display:var(--fa-display,inline-block);height:1em;overflow:visible;vertical-align:-.125em}.svg-inline--fa.fa-2xs{vertical-align:.1em}.svg-inline--fa.fa-xs{vertical-align:0}.svg-inline--fa.fa-sm{vertical-align:-.0714285705em}.svg-inline--fa.fa-lg{vertical-align:-.2em}.svg-inline--fa.fa-xl{vertical-align:-.25em}.svg-inline--fa.fa-2xl{vertical-align:-.3125em}.svg-inline--fa.fa-pull-left{margin-right:var(--fa-pull-margin,.3em);width:auto}.svg-inline--fa.fa-pull-right{margin-left:var(--fa-pull-margin,.3em);width:auto}.svg-inline--fa.fa-li{width:var(--fa-li-width,2em);top:.25em}.svg-inline--fa.fa-fw{width:var(--fa-fw-width,1.25em)}.fa-layers svg.svg-inline--fa{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0}.fa-layers-counter,.fa-layers-text{display:inline-block;position:absolute;text-align:center}.fa-layers{display:inline-block;height:1em;position:relative;text-align:center;vertical-align:-.125em;width:1em}.fa-layers svg.svg-inline--fa{transform-origin:center center}.fa-layers-text{left:50%;top:50%;transform:translate(-50%,-50%);transform-origin:center center}.fa-layers-counter{background-color:var(--fa-counter-background-color,#ff253a);border-radius:var(--fa-counter-border-radius,1em);box-sizing:border-box;color:var(--fa-inverse,#fff);line-height:var(--fa-counter-line-height,1);max-width:var(--fa-counter-max-width,5em);min-width:var(--fa-counter-min-width,1.5em);overflow:hidden;padding:var(--fa-counter-padding,.25em .5em);right:var(--fa-right,0);text-overflow:ellipsis;top:var(--fa-top,0);transform:scale(var(--fa-counter-scale,.25));transform-origin:top right}.fa-layers-bottom-right{bottom:var(--fa-bottom,0);right:var(--fa-right,0);top:auto;transform:scale(var(--fa-layers-scale,.25));transform-origin:bottom right}.fa-layers-bottom-left{bottom:var(--fa-bottom,0);left:var(--fa-left,0);right:auto;top:auto;transform:scale(var(--fa-layers-scale,.25));transform-origin:bottom left}.fa-layers-top-right{top:var(--fa-top,0);right:var(--fa-right,0);transform:scale(var(--fa-layers-scale,.25));transform-origin:top right}.fa-layers-top-left{left:var(--fa-left,0);right:auto;top:var(--fa-top,0);transform:scale(var(--fa-layers-scale,.25));transform-origin:top left}.fa-1x{font-size:1em}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-6x{font-size:6em}.fa-7x{font-size:7em}.fa-8x{font-size:8em}.fa-9x{font-size:9em}.fa-10x{font-size:10em}.fa-2xs{font-size:.625em;line-height:.1em;vertical-align:.225em}.fa-xs{font-size:.75em;line-height:.0833333337em;vertical-align:.125em}.fa-sm{font-size:.875em;line-height:.0714285718em;vertical-align:.0535714295em}.fa-lg{font-size:1.25em;line-height:.05em;vertical-align:-.075em}.fa-xl{font-size:1.5em;line-height:.0416666682em;vertical-align:-.125em}.fa-2xl{font-size:2em;line-height:.03125em;vertical-align:-.1875em}.fa-fw{text-align:center;width:1.25em}.fa-ul{list-style-type:none;margin-left:var(--fa-li-margin,2.5em);padding-left:0}.fa-ul&gt;li{position:relative}.fa-li{left:calc(-1 * var(--fa-li-width,2em));position:absolute;text-align:center;width:var(--fa-li-width,2em);line-height:inherit}.fa-border{border-color:var(--fa-border-color,#eee);border-radius:var(--fa-border-radius,.1em);border-style:var(--fa-border-style,solid);border-width:var(--fa-border-width,.08em);padding:var(--fa-border-padding,.2em .25em .15em)}.fa-pull-left{float:left;margin-right:var(--fa-pull-margin,.3em)}.fa-pull-right{float:right;margin-left:var(--fa-pull-margin,.3em)}.fa-beat{animation-name:fa-beat;animation-delay:var(--fa-animation-delay,0s);animation-direction:var(--fa-animation-direction,normal);animation-duration:var(--fa-animation-duration,1s);animation-iteration-count:var(--fa-animation-iteration-count,infinite);animation-timing-function:var(--fa-animation-timing,ease-in-out)}.fa-bounce{animation-name:fa-bounce;animation-delay:var(--fa-animation-delay,0s);animation-direction:var(--fa-animation-direction,normal);animation-duration:var(--fa-animation-duration,1s);animation-iteration-count:var(--fa-animation-iteration-count,infinite);animation-timing-function:var(--fa-animation-timing,cubic-bezier(.28,.84,.42,1))}.fa-fade{animation-name:fa-fade;animation-delay:var(--fa-animation-delay,0s);animation-direction:var(--fa-animation-direction,normal);animation-duration:var(--fa-animation-duration,1s);animation-iteration-count:var(--fa-animation-iteration-count,infinite);animation-timing-function:var(--fa-animation-timing,cubic-bezier(.4,0,.6,1))}.fa-beat-fade{animation-name:fa-beat-fade;animation-delay:var(--fa-animation-delay,0s);animation-direction:var(--fa-animation-direction,normal);animation-duration:var(--fa-animation-duration,1s);animation-iteration-count:var(--fa-animation-iteration-count,infinite);animation-timing-function:var(--fa-animation-timing,cubic-bezier(.4,0,.6,1))}.fa-flip{animation-name:fa-flip;animation-delay:var(--fa-animation-delay,0s);animation-direction:var(--fa-animation-direction,normal);animation-duration:var(--fa-animation-duration,1s);animation-iteration-count:var(--fa-animation-iteration-count,infinite);animation-timing-function:var(--fa-animation-timing,ease-in-out)}.fa-shake{animation-name:fa-shake;animation-delay:var(--fa-animation-delay,0s);animation-direction:var(--fa-animation-direction,normal);animation-duration:var(--fa-animation-duration,1s);animation-iteration-count:var(--fa-animation-iteration-count,infinite);animation-timing-function:var(--fa-animation-timing,linear)}.fa-spin{animation-name:fa-spin;animation-delay:var(--fa-animation-delay,0s);animation-direction:var(--fa-animation-direction,normal);animation-duration:var(--fa-animation-duration,2s);animation-iteration-count:var(--fa-animation-iteration-count,infinite);animation-timing-function:var(--fa-animation-timing,linear)}.fa-spin-reverse{--fa-animation-direction:reverse}.fa-pulse,.fa-spin-pulse{animation-name:fa-spin;animation-direction:var(--fa-animation-direction,normal);animation-duration:var(--fa-animation-duration,1s);animation-iteration-count:var(--fa-animation-iteration-count,infinite);animation-timing-function:var(--fa-animation-timing,steps(8))}@media (prefers-reduced-motion:reduce){.fa-beat,.fa-beat-fade,.fa-bounce,.fa-fade,.fa-flip,.fa-pulse,.fa-shake,.fa-spin,.fa-spin-pulse{animation-delay:-1ms;animation-duration:1ms;animation-iteration-count:1;transition-delay:0s;transition-duration:0s}}@keyframes fa-beat{0%,90%{transform:scale(1)}45%{transform:scale(var(--fa-beat-scale,1.25))}}@keyframes fa-bounce{0%{transform:scale(1,1) translateY(0)}10%{transform:scale(var(--fa-bounce-start-scale-x,1.1),var(--fa-bounce-start-scale-y,.9)) translateY(0)}30%{transform:scale(var(--fa-bounce-jump-scale-x,.9),var(--fa-bounce-jump-scale-y,1.1)) translateY(var(--fa-bounce-height,-.5em))}50%{transform:scale(var(--fa-bounce-land-scale-x,1.05),var(--fa-bounce-land-scale-y,.95)) translateY(0)}57%{transform:scale(1,1) translateY(var(--fa-bounce-rebound,-.125em))}64%{transform:scale(1,1) translateY(0)}100%{transform:scale(1,1) translateY(0)}}@keyframes fa-fade{50%{opacity:var(--fa-fade-opacity,.4)}}@keyframes fa-beat-fade{0%,100%{opacity:var(--fa-beat-fade-opacity,.4);transform:scale(1)}50%{opacity:1;transform:scale(var(--fa-beat-fade-scale,1.125))}}@keyframes fa-flip{50%{transform:rotate3d(var(--fa-flip-x,0),var(--fa-flip-y,1),var(--fa-flip-z,0),var(--fa-flip-angle,-180deg))}}@keyframes fa-shake{0%{transform:rotate(-15deg)}4%{transform:rotate(15deg)}24%,8%{transform:rotate(-18deg)}12%,28%{transform:rotate(18deg)}16%{transform:rotate(-22deg)}20%{transform:rotate(22deg)}32%{transform:rotate(-12deg)}36%{transform:rotate(12deg)}100%,40%{transform:rotate(0)}}@keyframes fa-spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}.fa-rotate-90{transform:rotate(90deg)}.fa-rotate-180{transform:rotate(180deg)}.fa-rotate-270{transform:rotate(270deg)}.fa-flip-horizontal{transform:scale(-1,1)}.fa-flip-vertical{transform:scale(1,-1)}.fa-flip-both,.fa-flip-horizontal.fa-flip-vertical{transform:scale(-1,-1)}.fa-rotate-by{transform:rotate(var(--fa-rotate-angle,0))}.fa-stack{display:inline-block;vertical-align:middle;height:2em;position:relative;width:2.5em}.fa-stack-1x,.fa-stack-2x{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0;z-index:var(--fa-stack-z-index,auto)}.svg-inline--fa.fa-stack-1x{height:1em;width:1.25em}.svg-inline--fa.fa-stack-2x{height:2em;width:2.5em}.fa-inverse{color:var(--fa-inverse,#fff)}.fa-sr-only,.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.fa-sr-only-focusable:not(:focus),.sr-only-focusable:not(:focus){position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.svg-inline--fa .fa-primary{fill:var(--fa-primary-color,currentColor);opacity:var(--fa-primary-opacity,1)}.svg-inline--fa .fa-secondary{fill:var(--fa-secondary-color,currentColor);opacity:var(--fa-secondary-opacity,.4)}.svg-inline--fa.fa-swap-opacity .fa-primary{opacity:var(--fa-secondary-opacity,.4)}.svg-inline--fa.fa-swap-opacity .fa-secondary{opacity:var(--fa-primary-opacity,1)}.svg-inline--fa mask .fa-primary,.svg-inline--fa mask .fa-secondary{fill:#000}&quot;;

  function css() {
    const dcp = DEFAULT_CSS_PREFIX;
    const drc = DEFAULT_REPLACEMENT_CLASS;
    const fp = config.cssPrefix;
    const rc = config.replacementClass;
    let s = baseStyles;
    if (fp !== dcp || rc !== drc) {
      const dPatt = new RegExp(&quot;\\.&quot;.concat(dcp, &quot;\\-&quot;), &#039;g&#039;);
      const customPropPatt = new RegExp(&quot;\\--&quot;.concat(dcp, &quot;\\-&quot;), &#039;g&#039;);
      const rPatt = new RegExp(&quot;\\.&quot;.concat(drc), &#039;g&#039;);
      s = s.replace(dPatt, &quot;.&quot;.concat(fp, &quot;-&quot;)).replace(customPropPatt, &quot;--&quot;.concat(fp, &quot;-&quot;)).replace(rPatt, &quot;.&quot;.concat(rc));
    }
    return s;
  }
  let _cssInserted = false;
  function ensureCss() {
    if (config.autoAddCss &amp;&amp; !_cssInserted) {
      insertCss(css());
      _cssInserted = true;
    }
  }
  var InjectCSS = {
    mixout() {
      return {
        dom: {
          css,
          insertCss: ensureCss
        }
      };
    },
    hooks() {
      return {
        beforeDOMElementCreation() {
          ensureCss();
        },
        beforeI2svg() {
          ensureCss();
        }
      };
    }
  };

  const w = WINDOW || {};
  if (!w[NAMESPACE_IDENTIFIER]) w[NAMESPACE_IDENTIFIER] = {};
  if (!w[NAMESPACE_IDENTIFIER].styles) w[NAMESPACE_IDENTIFIER].styles = {};
  if (!w[NAMESPACE_IDENTIFIER].hooks) w[NAMESPACE_IDENTIFIER].hooks = {};
  if (!w[NAMESPACE_IDENTIFIER].shims) w[NAMESPACE_IDENTIFIER].shims = [];
  var namespace = w[NAMESPACE_IDENTIFIER];

  const functions = [];
  const listener = function () {
    DOCUMENT.removeEventListener(&#039;DOMContentLoaded&#039;, listener);
    loaded = 1;
    functions.map(fn =&gt; fn());
  };
  let loaded = false;
  if (IS_DOM) {
    loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
    if (!loaded) DOCUMENT.addEventListener(&#039;DOMContentLoaded&#039;, listener);
  }
  function domready (fn) {
    if (!IS_DOM) return;
    loaded ? setTimeout(fn, 0) : functions.push(fn);
  }

  function toHtml(abstractNodes) {
    const {
      tag,
      attributes = {},
      children = []
    } = abstractNodes;
    if (typeof abstractNodes === &#039;string&#039;) {
      return htmlEscape(abstractNodes);
    } else {
      return &quot;&lt;&quot;.concat(tag, &quot; &quot;).concat(joinAttributes(attributes), &quot;&gt;&quot;).concat(children.map(toHtml).join(&#039;&#039;), &quot;&lt;/&quot;).concat(tag, &quot;&gt;&quot;);
    }
  }

  function iconFromMapping(mapping, prefix, iconName) {
    if (mapping &amp;&amp; mapping[prefix] &amp;&amp; mapping[prefix][iconName]) {
      return {
        prefix,
        iconName,
        icon: mapping[prefix][iconName]
      };
    }
  }

  /**
   * Internal helper to bind a function known to have 4 arguments
   * to a given context.
   */
  var bindInternal4 = function bindInternal4(func, thisContext) {
    return function (a, b, c, d) {
      return func.call(thisContext, a, b, c, d);
    };
  };

  /**
   * # Reduce
   *
   * A fast object `.reduce()` implementation.
   *
   * @param  {Object}   subject      The object to reduce over.
   * @param  {Function} fn           The reducer function.
   * @param  {mixed}    initialValue The initial value for the reducer, defaults to subject[0].
   * @param  {Object}   thisContext  The context for the reducer.
   * @return {mixed}                 The final result.
   */
  var reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {
    var keys = Object.keys(subject),
      length = keys.length,
      iterator = thisContext !== undefined ? bindInternal4(fn, thisContext) : fn,
      i,
      key,
      result;
    if (initialValue === undefined) {
      i = 1;
      result = subject[keys[0]];
    } else {
      i = 0;
      result = initialValue;
    }
    for (; i &lt; length; i++) {
      key = keys[i];
      result = iterator(result, subject[key], key, subject);
    }
    return result;
  };

  /**
   * ucs2decode() and codePointAt() are both works of Mathias Bynens and licensed under MIT
   *
   * Copyright Mathias Bynens &lt;https://mathiasbynens.be/&gt;

   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * &quot;Software&quot;), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:

   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */

  function ucs2decode(string) {
    const output = [];
    let counter = 0;
    const length = string.length;
    while (counter &lt; length) {
      const value = string.charCodeAt(counter++);
      if (value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDBFF &amp;&amp; counter &lt; length) {
        const extra = string.charCodeAt(counter++);
        if ((extra &amp; 0xFC00) == 0xDC00) {
          // eslint-disable-line eqeqeq
          output.push(((value &amp; 0x3FF) &lt;&lt; 10) + (extra &amp; 0x3FF) + 0x10000);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }
  function toHex(unicode) {
    const decoded = ucs2decode(unicode);
    return decoded.length === 1 ? decoded[0].toString(16) : null;
  }
  function codePointAt(string, index) {
    const size = string.length;
    let first = string.charCodeAt(index);
    let second;
    if (first &gt;= 0xD800 &amp;&amp; first &lt;= 0xDBFF &amp;&amp; size &gt; index + 1) {
      second = string.charCodeAt(index + 1);
      if (second &gt;= 0xDC00 &amp;&amp; second &lt;= 0xDFFF) {
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return first;
  }

  function normalizeIcons(icons) {
    return Object.keys(icons).reduce((acc, iconName) =&gt; {
      const icon = icons[iconName];
      const expanded = !!icon.icon;
      if (expanded) {
        acc[icon.iconName] = icon.icon;
      } else {
        acc[iconName] = icon;
      }
      return acc;
    }, {});
  }
  function defineIcons(prefix, icons) {
    let params = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : {};
    const {
      skipHooks = false
    } = params;
    const normalized = normalizeIcons(icons);
    if (typeof namespace.hooks.addPack === &#039;function&#039; &amp;&amp; !skipHooks) {
      namespace.hooks.addPack(prefix, normalizeIcons(icons));
    } else {
      namespace.styles[prefix] = _objectSpread2(_objectSpread2({}, namespace.styles[prefix] || {}), normalized);
    }

    /**
     * Font Awesome 4 used the prefix of `fa` for all icons. With the introduction
     * of new styles we needed to differentiate between them. Prefix `fa` is now an alias
     * for `fas` so we&#039;ll ease the upgrade process for our users by automatically defining
     * this as well.
     */
    if (prefix === &#039;fas&#039;) {
      defineIcons(&#039;fa&#039;, icons);
    }
  }

  const duotonePathRe = [/*#__PURE__*/_wrapRegExp(/path d=&quot;([^&quot;]+)&quot;.*path d=&quot;([^&quot;]+)&quot;/, {
    d1: 1,
    d2: 2
  }), /*#__PURE__*/_wrapRegExp(/path class=&quot;([^&quot;]+)&quot;.*d=&quot;([^&quot;]+)&quot;.*path class=&quot;([^&quot;]+)&quot;.*d=&quot;([^&quot;]+)&quot;/, {
    cls1: 1,
    d1: 2,
    cls2: 3,
    d2: 4
  }), /*#__PURE__*/_wrapRegExp(/path class=&quot;([^&quot;]+)&quot;.*d=&quot;([^&quot;]+)&quot;/, {
    cls1: 1,
    d1: 2
  })];

  const {
    styles,
    shims
  } = namespace;
  const FAMILY_NAMES = Object.keys(PREFIX_TO_LONG_STYLE);
  const PREFIXES_FOR_FAMILY = FAMILY_NAMES.reduce((acc, familyId) =&gt; {
    acc[familyId] = Object.keys(PREFIX_TO_LONG_STYLE[familyId]);
    return acc;
  }, {});
  let _defaultUsablePrefix = null;
  let _byUnicode = {};
  let _byLigature = {};
  let _byOldName = {};
  let _byOldUnicode = {};
  let _byAlias = {};
  function isReserved(name) {
    return ~RESERVED_CLASSES.indexOf(name);
  }
  function getIconName(cssPrefix, cls) {
    const parts = cls.split(&#039;-&#039;);
    const prefix = parts[0];
    const iconName = parts.slice(1).join(&#039;-&#039;);
    if (prefix === cssPrefix &amp;&amp; iconName !== &#039;&#039; &amp;&amp; !isReserved(iconName)) {
      return iconName;
    } else {
      return null;
    }
  }
  const build = () =&gt; {
    const lookup = reducer =&gt; {
      return reduce(styles, (o$$1, style, prefix) =&gt; {
        o$$1[prefix] = reduce(style, reducer, {});
        return o$$1;
      }, {});
    };
    _byUnicode = lookup((acc, icon, iconName) =&gt; {
      if (icon[3]) {
        acc[icon[3]] = iconName;
      }
      if (icon[2]) {
        const aliases = icon[2].filter(a$$1 =&gt; {
          return typeof a$$1 === &#039;number&#039;;
        });
        aliases.forEach(alias =&gt; {
          acc[alias.toString(16)] = iconName;
        });
      }
      return acc;
    });
    _byLigature = lookup((acc, icon, iconName) =&gt; {
      acc[iconName] = iconName;
      if (icon[2]) {
        const aliases = icon[2].filter(a$$1 =&gt; {
          return typeof a$$1 === &#039;string&#039;;
        });
        aliases.forEach(alias =&gt; {
          acc[alias] = iconName;
        });
      }
      return acc;
    });
    _byAlias = lookup((acc, icon, iconName) =&gt; {
      const aliases = icon[2];
      acc[iconName] = iconName;
      aliases.forEach(alias =&gt; {
        acc[alias] = iconName;
      });
      return acc;
    });

    // If we have a Kit, we can&#039;t determine if regular is available since we
    // could be auto-fetching it. We&#039;ll have to assume that it is available.
    const hasRegular = &#039;far&#039; in styles || config.autoFetchSvg;
    const shimLookups = reduce(shims, (acc, shim) =&gt; {
      const maybeNameMaybeUnicode = shim[0];
      let prefix = shim[1];
      const iconName = shim[2];
      if (prefix === &#039;far&#039; &amp;&amp; !hasRegular) {
        prefix = &#039;fas&#039;;
      }
      if (typeof maybeNameMaybeUnicode === &#039;string&#039;) {
        acc.names[maybeNameMaybeUnicode] = {
          prefix,
          iconName
        };
      }
      if (typeof maybeNameMaybeUnicode === &#039;number&#039;) {
        acc.unicodes[maybeNameMaybeUnicode.toString(16)] = {
          prefix,
          iconName
        };
      }
      return acc;
    }, {
      names: {},
      unicodes: {}
    });
    _byOldName = shimLookups.names;
    _byOldUnicode = shimLookups.unicodes;
    _defaultUsablePrefix = getCanonicalPrefix(config.styleDefault, {
      family: config.familyDefault
    });
  };
  onChange(c$$1 =&gt; {
    _defaultUsablePrefix = getCanonicalPrefix(c$$1.styleDefault, {
      family: config.familyDefault
    });
  });
  build();
  function byUnicode(prefix, unicode) {
    return (_byUnicode[prefix] || {})[unicode];
  }
  function byLigature(prefix, ligature) {
    return (_byLigature[prefix] || {})[ligature];
  }
  function byAlias(prefix, alias) {
    return (_byAlias[prefix] || {})[alias];
  }
  function byOldName(name) {
    return _byOldName[name] || {
      prefix: null,
      iconName: null
    };
  }
  function byOldUnicode(unicode) {
    const oldUnicode = _byOldUnicode[unicode];
    const newUnicode = byUnicode(&#039;fas&#039;, unicode);
    return oldUnicode || (newUnicode ? {
      prefix: &#039;fas&#039;,
      iconName: newUnicode
    } : null) || {
      prefix: null,
      iconName: null
    };
  }
  function getDefaultUsablePrefix() {
    return _defaultUsablePrefix;
  }
  const emptyCanonicalIcon = () =&gt; {
    return {
      prefix: null,
      iconName: null,
      rest: []
    };
  };
  function getFamilyId(values) {
    let family = s;
    const famProps = FAMILY_NAMES.reduce((acc, familyId) =&gt; {
      acc[familyId] = &quot;&quot;.concat(config.cssPrefix, &quot;-&quot;).concat(familyId);
      return acc;
    }, {});
    L.forEach(familyId =&gt; {
      if (values.includes(famProps[familyId]) || values.some(v$$1 =&gt; PREFIXES_FOR_FAMILY[familyId].includes(v$$1))) {
        family = familyId;
      }
    });
    return family;
  }
  function getCanonicalPrefix(styleOrPrefix) {
    let params = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : {};
    const {
      family = s
    } = params;
    const style = PREFIX_TO_STYLE[family][styleOrPrefix];

    // handles the exception of passing in only a family of &#039;duotone&#039; with no style
    if (family === t &amp;&amp; !styleOrPrefix) {
      return &#039;fad&#039;;
    }
    const prefix = STYLE_TO_PREFIX[family][styleOrPrefix] || STYLE_TO_PREFIX[family][style];
    const defined = styleOrPrefix in namespace.styles ? styleOrPrefix : null;
    const result = prefix || defined || null;
    return result;
  }
  function moveNonFaClassesToRest(classNames) {
    let rest = [];
    let iconName = null;
    classNames.forEach(cls =&gt; {
      const result = getIconName(config.cssPrefix, cls);
      if (result) {
        iconName = result;
      } else if (cls) {
        rest.push(cls);
      }
    });
    return {
      iconName,
      rest
    };
  }
  function sortedUniqueValues(arr) {
    return arr.sort().filter((value, index, arr) =&gt; {
      return arr.indexOf(value) === index;
    });
  }
  function getCanonicalIcon(values) {
    let params = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : {};
    const {
      skipLookups = false
    } = params;
    let givenPrefix = null;
    const faCombinedClasses = Ia.concat(bt$1);
    const faStyleOrFamilyClasses = sortedUniqueValues(values.filter(cls =&gt; faCombinedClasses.includes(cls)));
    const nonStyleOrFamilyClasses = sortedUniqueValues(values.filter(cls =&gt; !Ia.includes(cls)));
    const faStyles = faStyleOrFamilyClasses.filter(cls =&gt; {
      givenPrefix = cls;
      return !P.includes(cls);
    });
    const [styleFromValues = null] = faStyles;
    const family = getFamilyId(faStyleOrFamilyClasses);
    const canonical = _objectSpread2(_objectSpread2({}, moveNonFaClassesToRest(nonStyleOrFamilyClasses)), {}, {
      prefix: getCanonicalPrefix(styleFromValues, {
        family
      })
    });
    return _objectSpread2(_objectSpread2(_objectSpread2({}, canonical), getDefaultCanonicalPrefix({
      values,
      family,
      styles,
      config,
      canonical,
      givenPrefix
    })), applyShimAndAlias(skipLookups, givenPrefix, canonical));
  }
  function applyShimAndAlias(skipLookups, givenPrefix, canonical) {
    let {
      prefix,
      iconName
    } = canonical;
    if (skipLookups || !prefix || !iconName) {
      return {
        prefix,
        iconName
      };
    }
    const shim = givenPrefix === &#039;fa&#039; ? byOldName(iconName) : {};
    const aliasIconName = byAlias(prefix, iconName);
    iconName = shim.iconName || aliasIconName || iconName;
    prefix = shim.prefix || prefix;
    if (prefix === &#039;far&#039; &amp;&amp; !styles[&#039;far&#039;] &amp;&amp; styles[&#039;fas&#039;] &amp;&amp; !config.autoFetchSvg) {
      // Allow a fallback from the regular style to solid if regular is not available
      // but only if we aren&#039;t auto-fetching SVGs
      prefix = &#039;fas&#039;;
    }
    return {
      prefix,
      iconName
    };
  }
  const newCanonicalFamilies = L.filter(familyId =&gt; {
    return familyId !== s || familyId !== t;
  });
  const newCanonicalStyles = Object.keys(ga).filter(key =&gt; key !== s).map(key =&gt; Object.keys(ga[key])).flat();
  function getDefaultCanonicalPrefix(prefixOptions) {
    const {
      values,
      family,
      canonical,
      givenPrefix = &#039;&#039;,
      styles = {},
      config: config$$1 = {}
    } = prefixOptions;
    const isDuotoneFamily = family === t;
    const valuesHasDuotone = values.includes(&#039;fa-duotone&#039;) || values.includes(&#039;fad&#039;);
    const defaultFamilyIsDuotone = config$$1.familyDefault === &#039;duotone&#039;;
    const canonicalPrefixIsDuotone = canonical.prefix === &#039;fad&#039; || canonical.prefix === &#039;fa-duotone&#039;;
    if (!isDuotoneFamily &amp;&amp; (valuesHasDuotone || defaultFamilyIsDuotone || canonicalPrefixIsDuotone)) {
      canonical.prefix = &#039;fad&#039;;
    }
    if (values.includes(&#039;fa-brands&#039;) || values.includes(&#039;fab&#039;)) {
      canonical.prefix = &#039;fab&#039;;
    }
    if (!canonical.prefix &amp;&amp; newCanonicalFamilies.includes(family)) {
      const validPrefix = Object.keys(styles).find(key =&gt; newCanonicalStyles.includes(key));
      if (validPrefix || config$$1.autoFetchSvg) {
        const defaultPrefix = pt.get(family).defaultShortPrefixId;
        canonical.prefix = defaultPrefix;
        canonical.iconName = byAlias(canonical.prefix, canonical.iconName) || canonical.iconName;
      }
    }
    if (canonical.prefix === &#039;fa&#039; || givenPrefix === &#039;fa&#039;) {
      // The fa prefix is not canonical. So if it has made it through until this point
      // we will shift it to the correct prefix.
      canonical.prefix = getDefaultUsablePrefix() || &#039;fas&#039;;
    }
    return canonical;
  }

  class Library {
    constructor() {
      this.definitions = {};
    }
    add() {
      for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key &lt; _len; _key++) {
        definitions[_key] = arguments[_key];
      }
      const additions = definitions.reduce(this._pullDefinitions, {});
      Object.keys(additions).forEach(key =&gt; {
        this.definitions[key] = _objectSpread2(_objectSpread2({}, this.definitions[key] || {}), additions[key]);
        defineIcons(key, additions[key]);

        // TODO can we stop doing this? We can&#039;t get the icons by &#039;fa-solid&#039; any longer so this probably needs to change
        const longPrefix = PREFIX_TO_LONG_STYLE[s][key];
        if (longPrefix) defineIcons(longPrefix, additions[key]);
        build();
      });
    }
    reset() {
      this.definitions = {};
    }
    _pullDefinitions(additions, definition) {
      const normalized = definition.prefix &amp;&amp; definition.iconName &amp;&amp; definition.icon ? {
        0: definition
      } : definition;
      Object.keys(normalized).map(key =&gt; {
        const {
          prefix,
          iconName,
          icon
        } = normalized[key];
        const aliases = icon[2];
        if (!additions[prefix]) additions[prefix] = {};
        if (aliases.length &gt; 0) {
          aliases.forEach(alias =&gt; {
            if (typeof alias === &#039;string&#039;) {
              additions[prefix][alias] = icon;
            }
          });
        }
        additions[prefix][iconName] = icon;
      });
      return additions;
    }
  }

  let _plugins = [];
  let _hooks = {};
  const providers = {};
  const defaultProviderKeys = Object.keys(providers);
  function registerPlugins(nextPlugins, _ref) {
    let {
      mixoutsTo: obj
    } = _ref;
    _plugins = nextPlugins;
    _hooks = {};
    Object.keys(providers).forEach(k =&gt; {
      if (defaultProviderKeys.indexOf(k) === -1) {
        delete providers[k];
      }
    });
    _plugins.forEach(plugin =&gt; {
      const mixout = plugin.mixout ? plugin.mixout() : {};
      Object.keys(mixout).forEach(tk =&gt; {
        if (typeof mixout[tk] === &#039;function&#039;) {
          obj[tk] = mixout[tk];
        }
        if (typeof mixout[tk] === &#039;object&#039;) {
          Object.keys(mixout[tk]).forEach(sk =&gt; {
            if (!obj[tk]) {
              obj[tk] = {};
            }
            obj[tk][sk] = mixout[tk][sk];
          });
        }
      });
      if (plugin.hooks) {
        const hooks = plugin.hooks();
        Object.keys(hooks).forEach(hook =&gt; {
          if (!_hooks[hook]) {
            _hooks[hook] = [];
          }
          _hooks[hook].push(hooks[hook]);
        });
      }
      if (plugin.provides) {
        plugin.provides(providers);
      }
    });
    return obj;
  }
  function chainHooks(hook, accumulator) {
    for (var _len = arguments.length, args = new Array(_len &gt; 2 ? _len - 2 : 0), _key = 2; _key &lt; _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    const hookFns = _hooks[hook] || [];
    hookFns.forEach(hookFn =&gt; {
      accumulator = hookFn.apply(null, [accumulator, ...args]); // eslint-disable-line no-useless-call
    });
    return accumulator;
  }
  function callHooks(hook) {
    for (var _len2 = arguments.length, args = new Array(_len2 &gt; 1 ? _len2 - 1 : 0), _key2 = 1; _key2 &lt; _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    const hookFns = _hooks[hook] || [];
    hookFns.forEach(hookFn =&gt; {
      hookFn.apply(null, args);
    });
    return undefined;
  }
  function callProvided() {
    const hook = arguments[0];
    const args = Array.prototype.slice.call(arguments, 1);
    return providers[hook] ? providers[hook].apply(null, args) : undefined;
  }

  function findIconDefinition(iconLookup) {
    if (iconLookup.prefix === &#039;fa&#039;) {
      iconLookup.prefix = &#039;fas&#039;;
    }
    let {
      iconName
    } = iconLookup;
    const prefix = iconLookup.prefix || getDefaultUsablePrefix();
    if (!iconName) return;
    iconName = byAlias(prefix, iconName) || iconName;
    return iconFromMapping(library.definitions, prefix, iconName) || iconFromMapping(namespace.styles, prefix, iconName);
  }
  const library = new Library();
  const noAuto = () =&gt; {
    config.autoReplaceSvg = false;
    config.observeMutations = false;
    callHooks(&#039;noAuto&#039;);
  };
  const dom = {
    i2svg: function () {
      let params = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : {};
      if (IS_DOM) {
        callHooks(&#039;beforeI2svg&#039;, params);
        callProvided(&#039;pseudoElements2svg&#039;, params);
        return callProvided(&#039;i2svg&#039;, params);
      } else {
        return Promise.reject(new Error(&#039;Operation requires a DOM of some kind.&#039;));
      }
    },
    watch: function () {
      let params = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : {};
      const {
        autoReplaceSvgRoot
      } = params;
      if (config.autoReplaceSvg === false) {
        config.autoReplaceSvg = true;
      }
      config.observeMutations = true;
      domready(() =&gt; {
        autoReplace({
          autoReplaceSvgRoot
        });
        callHooks(&#039;watch&#039;, params);
      });
    }
  };
  const parse = {
    icon: icon =&gt; {
      if (icon === null) {
        return null;
      }
      if (typeof icon === &#039;object&#039; &amp;&amp; icon.prefix &amp;&amp; icon.iconName) {
        return {
          prefix: icon.prefix,
          iconName: byAlias(icon.prefix, icon.iconName) || icon.iconName
        };
      }
      if (Array.isArray(icon) &amp;&amp; icon.length === 2) {
        const iconName = icon[1].indexOf(&#039;fa-&#039;) === 0 ? icon[1].slice(3) : icon[1];
        const prefix = getCanonicalPrefix(icon[0]);
        return {
          prefix,
          iconName: byAlias(prefix, iconName) || iconName
        };
      }
      if (typeof icon === &#039;string&#039; &amp;&amp; (icon.indexOf(&quot;&quot;.concat(config.cssPrefix, &quot;-&quot;)) &gt; -1 || icon.match(ICON_SELECTION_SYNTAX_PATTERN))) {
        const canonicalIcon = getCanonicalIcon(icon.split(&#039; &#039;), {
          skipLookups: true
        });
        return {
          prefix: canonicalIcon.prefix || getDefaultUsablePrefix(),
          iconName: byAlias(canonicalIcon.prefix, canonicalIcon.iconName) || canonicalIcon.iconName
        };
      }
      if (typeof icon === &#039;string&#039;) {
        const prefix = getDefaultUsablePrefix();
        return {
          prefix,
          iconName: byAlias(prefix, icon) || icon
        };
      }
    }
  };
  const api = {
    noAuto,
    config,
    dom,
    parse,
    library,
    findIconDefinition,
    toHtml
  };
  const autoReplace = function () {
    let params = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : {};
    const {
      autoReplaceSvgRoot = DOCUMENT
    } = params;
    if ((Object.keys(namespace.styles).length &gt; 0 || config.autoFetchSvg) &amp;&amp; IS_DOM &amp;&amp; config.autoReplaceSvg) api.dom.i2svg({
      node: autoReplaceSvgRoot
    });
  };
  function bootstrap(plugins) {
    if (IS_BROWSER) {
      if (!WINDOW.FontAwesome) {
        WINDOW.FontAwesome = api;
      }
      domready(() =&gt; {
        autoReplace();
        callHooks(&#039;bootstrap&#039;);
      });
    }
    namespace.hooks = _objectSpread2(_objectSpread2({}, namespace.hooks), {}, {
      addPack: (prefix, icons) =&gt; {
        namespace.styles[prefix] = _objectSpread2(_objectSpread2({}, namespace.styles[prefix] || {}), icons);
        build();
        autoReplace();
      },
      addPacks: packs =&gt; {
        packs.forEach(_ref =&gt; {
          let [prefix, icons] = _ref;
          namespace.styles[prefix] = _objectSpread2(_objectSpread2({}, namespace.styles[prefix] || {}), icons);
        });
        build();
        autoReplace();
      },
      addShims: shims =&gt; {
        namespace.shims.push(...shims);
        build();
        autoReplace();
      }
    });
  }

  function domVariants(val, abstractCreator) {
    Object.defineProperty(val, &#039;abstract&#039;, {
      get: abstractCreator
    });
    Object.defineProperty(val, &#039;html&#039;, {
      get: function () {
        return val.abstract.map(a =&gt; toHtml(a));
      }
    });
    Object.defineProperty(val, &#039;node&#039;, {
      get: function () {
        if (!IS_DOM) return;
        const container = DOCUMENT.createElement(&#039;div&#039;);
        container.innerHTML = val.html;
        return container.children;
      }
    });
    return val;
  }

  function asIcon (_ref) {
    let {
      children,
      main,
      mask,
      attributes,
      styles,
      transform
    } = _ref;
    if (transformIsMeaningful(transform) &amp;&amp; main.found &amp;&amp; !mask.found) {
      const {
        width,
        height
      } = main;
      const offset = {
        x: width / height / 2,
        y: 0.5
      };
      attributes[&#039;style&#039;] = joinStyles(_objectSpread2(_objectSpread2({}, styles), {}, {
        &#039;transform-origin&#039;: &quot;&quot;.concat(offset.x + transform.x / 16, &quot;em &quot;).concat(offset.y + transform.y / 16, &quot;em&quot;)
      }));
    }
    return [{
      tag: &#039;svg&#039;,
      attributes,
      children
    }];
  }

  function asSymbol (_ref) {
    let {
      prefix,
      iconName,
      children,
      attributes,
      symbol
    } = _ref;
    const id = symbol === true ? &quot;&quot;.concat(prefix, &quot;-&quot;).concat(config.cssPrefix, &quot;-&quot;).concat(iconName) : symbol;
    return [{
      tag: &#039;svg&#039;,
      attributes: {
        style: &#039;display: none;&#039;
      },
      children: [{
        tag: &#039;symbol&#039;,
        attributes: _objectSpread2(_objectSpread2({}, attributes), {}, {
          id
        }),
        children
      }]
    }];
  }

  function makeInlineSvgAbstract(params) {
    const {
      icons: {
        main,
        mask
      },
      prefix,
      iconName,
      transform,
      symbol,
      title,
      maskId,
      titleId,
      extra,
      watchable = false
    } = params;
    const {
      width,
      height
    } = mask.found ? mask : main;
    const isUploadedIcon = Lt.includes(prefix);
    const attrClass = [config.replacementClass, iconName ? &quot;&quot;.concat(config.cssPrefix, &quot;-&quot;).concat(iconName) : &#039;&#039;].filter(c$$1 =&gt; extra.classes.indexOf(c$$1) === -1).filter(c$$1 =&gt; c$$1 !== &#039;&#039; || !!c$$1).concat(extra.classes).join(&#039; &#039;);
    let content = {
      children: [],
      attributes: _objectSpread2(_objectSpread2({}, extra.attributes), {}, {
        &#039;data-prefix&#039;: prefix,
        &#039;data-icon&#039;: iconName,
        &#039;class&#039;: attrClass,
        &#039;role&#039;: extra.attributes.role || &#039;img&#039;,
        &#039;xmlns&#039;: &#039;http://www.w3.org/2000/svg&#039;,
        &#039;viewBox&#039;: &quot;0 0 &quot;.concat(width, &quot; &quot;).concat(height)
      })
    };
    const uploadedIconWidthStyle = isUploadedIcon &amp;&amp; !~extra.classes.indexOf(&#039;fa-fw&#039;) ? {
      width: &quot;&quot;.concat(width / height * 16 * 0.0625, &quot;em&quot;)
    } : {};
    if (watchable) {
      content.attributes[DATA_FA_I2SVG] = &#039;&#039;;
    }
    if (title) {
      content.children.push({
        tag: &#039;title&#039;,
        attributes: {
          id: content.attributes[&#039;aria-labelledby&#039;] || &quot;title-&quot;.concat(titleId || nextUniqueId())
        },
        children: [title]
      });
      delete content.attributes.title;
    }
    const args = _objectSpread2(_objectSpread2({}, content), {}, {
      prefix,
      iconName,
      main,
      mask,
      maskId,
      transform,
      symbol,
      styles: _objectSpread2(_objectSpread2({}, uploadedIconWidthStyle), extra.styles)
    });
    const {
      children,
      attributes
    } = mask.found &amp;&amp; main.found ? callProvided(&#039;generateAbstractMask&#039;, args) || {
      children: [],
      attributes: {}
    } : callProvided(&#039;generateAbstractIcon&#039;, args) || {
      children: [],
      attributes: {}
    };
    args.children = children;
    args.attributes = attributes;
    if (symbol) {
      return asSymbol(args);
    } else {
      return asIcon(args);
    }
  }
  function makeLayersTextAbstract(params) {
    const {
      content,
      width,
      height,
      transform,
      title,
      extra,
      watchable = false
    } = params;
    const attributes = _objectSpread2(_objectSpread2(_objectSpread2({}, extra.attributes), title ? {
      &#039;title&#039;: title
    } : {}), {}, {
      &#039;class&#039;: extra.classes.join(&#039; &#039;)
    });
    if (watchable) {
      attributes[DATA_FA_I2SVG] = &#039;&#039;;
    }
    const styles = _objectSpread2({}, extra.styles);
    if (transformIsMeaningful(transform)) {
      styles[&#039;transform&#039;] = transformForCss({
        transform,
        startCentered: true,
        width,
        height
      });
      styles[&#039;-webkit-transform&#039;] = styles[&#039;transform&#039;];
    }
    const styleString = joinStyles(styles);
    if (styleString.length &gt; 0) {
      attributes[&#039;style&#039;] = styleString;
    }
    const val = [];
    val.push({
      tag: &#039;span&#039;,
      attributes,
      children: [content]
    });
    if (title) {
      val.push({
        tag: &#039;span&#039;,
        attributes: {
          class: &#039;sr-only&#039;
        },
        children: [title]
      });
    }
    return val;
  }
  function makeLayersCounterAbstract(params) {
    const {
      content,
      title,
      extra
    } = params;
    const attributes = _objectSpread2(_objectSpread2(_objectSpread2({}, extra.attributes), title ? {
      &#039;title&#039;: title
    } : {}), {}, {
      &#039;class&#039;: extra.classes.join(&#039; &#039;)
    });
    const styleString = joinStyles(extra.styles);
    if (styleString.length &gt; 0) {
      attributes[&#039;style&#039;] = styleString;
    }
    const val = [];
    val.push({
      tag: &#039;span&#039;,
      attributes,
      children: [content]
    });
    if (title) {
      val.push({
        tag: &#039;span&#039;,
        attributes: {
          class: &#039;sr-only&#039;
        },
        children: [title]
      });
    }
    return val;
  }

  const {
    styles: styles$1
  } = namespace;
  function asFoundIcon(icon) {
    const width = icon[0];
    const height = icon[1];
    const [vectorData] = icon.slice(4);
    let element = null;
    if (Array.isArray(vectorData)) {
      element = {
        tag: &#039;g&#039;,
        attributes: {
          class: &quot;&quot;.concat(config.cssPrefix, &quot;-&quot;).concat(DUOTONE_CLASSES.GROUP)
        },
        children: [{
          tag: &#039;path&#039;,
          attributes: {
            class: &quot;&quot;.concat(config.cssPrefix, &quot;-&quot;).concat(DUOTONE_CLASSES.SECONDARY),
            fill: &#039;currentColor&#039;,
            d: vectorData[0]
          }
        }, {
          tag: &#039;path&#039;,
          attributes: {
            class: &quot;&quot;.concat(config.cssPrefix, &quot;-&quot;).concat(DUOTONE_CLASSES.PRIMARY),
            fill: &#039;currentColor&#039;,
            d: vectorData[1]
          }
        }]
      };
    } else {
      element = {
        tag: &#039;path&#039;,
        attributes: {
          fill: &#039;currentColor&#039;,
          d: vectorData
        }
      };
    }
    return {
      found: true,
      width,
      height,
      icon: element
    };
  }
  const missingIconResolutionMixin = {
    found: false,
    width: 512,
    height: 512
  };
  function maybeNotifyMissing(iconName, prefix) {
    if (!PRODUCTION &amp;&amp; !config.showMissingIcons &amp;&amp; iconName) {
      console.error(&quot;Icon with name \&quot;&quot;.concat(iconName, &quot;\&quot; and prefix \&quot;&quot;).concat(prefix, &quot;\&quot; is missing.&quot;));
    }
  }
  function findIcon(iconName, prefix) {
    let givenPrefix = prefix;
    if (prefix === &#039;fa&#039; &amp;&amp; config.styleDefault !== null) {
      prefix = getDefaultUsablePrefix();
    }
    return new Promise((resolve, reject) =&gt; {
      if (givenPrefix === &#039;fa&#039;) {
        const shim = byOldName(iconName) || {};
        iconName = shim.iconName || iconName;
        prefix = shim.prefix || prefix;
      }
      if (iconName &amp;&amp; prefix &amp;&amp; styles$1[prefix] &amp;&amp; styles$1[prefix][iconName]) {
        const icon = styles$1[prefix][iconName];
        return resolve(asFoundIcon(icon));
      }
      maybeNotifyMissing(iconName, prefix);
      resolve(_objectSpread2(_objectSpread2({}, missingIconResolutionMixin), {}, {
        icon: config.showMissingIcons &amp;&amp; iconName ? callProvided(&#039;missingIconAbstract&#039;) || {} : {}
      }));
    });
  }

  const noop$1 = () =&gt; {};
  const p$2 = config.measurePerformance &amp;&amp; PERFORMANCE &amp;&amp; PERFORMANCE.mark &amp;&amp; PERFORMANCE.measure ? PERFORMANCE : {
    mark: noop$1,
    measure: noop$1
  };
  const preamble = &quot;FA \&quot;6.7.2\&quot;&quot;;
  const begin = name =&gt; {
    p$2.mark(&quot;&quot;.concat(preamble, &quot; &quot;).concat(name, &quot; begins&quot;));
    return () =&gt; end(name);
  };
  const end = name =&gt; {
    p$2.mark(&quot;&quot;.concat(preamble, &quot; &quot;).concat(name, &quot; ends&quot;));
    p$2.measure(&quot;&quot;.concat(preamble, &quot; &quot;).concat(name), &quot;&quot;.concat(preamble, &quot; &quot;).concat(name, &quot; begins&quot;), &quot;&quot;.concat(preamble, &quot; &quot;).concat(name, &quot; ends&quot;));
  };
  var perf = {
    begin,
    end
  };

  const noop$2 = () =&gt; {};
  function isWatched(node) {
    const i2svg = node.getAttribute ? node.getAttribute(DATA_FA_I2SVG) : null;
    return typeof i2svg === &#039;string&#039;;
  }
  function hasPrefixAndIcon(node) {
    const prefix = node.getAttribute ? node.getAttribute(DATA_PREFIX) : null;
    const icon = node.getAttribute ? node.getAttribute(DATA_ICON) : null;
    return prefix &amp;&amp; icon;
  }
  function hasBeenReplaced(node) {
    return node &amp;&amp; node.classList &amp;&amp; node.classList.contains &amp;&amp; node.classList.contains(config.replacementClass);
  }
  function getMutator() {
    if (config.autoReplaceSvg === true) {
      return mutators.replace;
    }
    const mutator = mutators[config.autoReplaceSvg];
    return mutator || mutators.replace;
  }
  function createElementNS(tag) {
    return DOCUMENT.createElementNS(&#039;http://www.w3.org/2000/svg&#039;, tag);
  }
  function createElement(tag) {
    return DOCUMENT.createElement(tag);
  }
  function convertSVG(abstractObj) {
    let params = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : {};
    const {
      ceFn = abstractObj.tag === &#039;svg&#039; ? createElementNS : createElement
    } = params;
    if (typeof abstractObj === &#039;string&#039;) {
      return DOCUMENT.createTextNode(abstractObj);
    }
    const tag = ceFn(abstractObj.tag);
    Object.keys(abstractObj.attributes || []).forEach(function (key) {
      tag.setAttribute(key, abstractObj.attributes[key]);
    });
    const children = abstractObj.children || [];
    children.forEach(function (child) {
      tag.appendChild(convertSVG(child, {
        ceFn
      }));
    });
    return tag;
  }
  function nodeAsComment(node) {
    let comment = &quot; &quot;.concat(node.outerHTML, &quot; &quot;);
    /* BEGIN.ATTRIBUTION */
    comment = &quot;&quot;.concat(comment, &quot;Font Awesome fontawesome.com &quot;);
    /* END.ATTRIBUTION */
    return comment;
  }
  const mutators = {
    replace: function (mutation) {
      const node = mutation[0];
      if (node.parentNode) {
        mutation[1].forEach(abstract =&gt; {
          node.parentNode.insertBefore(convertSVG(abstract), node);
        });
        if (node.getAttribute(DATA_FA_I2SVG) === null &amp;&amp; config.keepOriginalSource) {
          let comment = DOCUMENT.createComment(nodeAsComment(node));
          node.parentNode.replaceChild(comment, node);
        } else {
          node.remove();
        }
      }
    },
    nest: function (mutation) {
      const node = mutation[0];
      const abstract = mutation[1];

      // If we already have a replaced node we do not want to continue nesting within it.
      // Short-circuit to the standard replacement
      if (~classArray(node).indexOf(config.replacementClass)) {
        return mutators.replace(mutation);
      }
      const forSvg = new RegExp(&quot;&quot;.concat(config.cssPrefix, &quot;-.*&quot;));
      delete abstract[0].attributes.id;
      if (abstract[0].attributes.class) {
        const splitClasses = abstract[0].attributes.class.split(&#039; &#039;).reduce((acc, cls) =&gt; {
          if (cls === config.replacementClass || cls.match(forSvg)) {
            acc.toSvg.push(cls);
          } else {
            acc.toNode.push(cls);
          }
          return acc;
        }, {
          toNode: [],
          toSvg: []
        });
        abstract[0].attributes.class = splitClasses.toSvg.join(&#039; &#039;);
        if (splitClasses.toNode.length === 0) {
          node.removeAttribute(&#039;class&#039;);
        } else {
          node.setAttribute(&#039;class&#039;, splitClasses.toNode.join(&#039; &#039;));
        }
      }
      const newInnerHTML = abstract.map(a =&gt; toHtml(a)).join(&#039;\n&#039;);
      node.setAttribute(DATA_FA_I2SVG, &#039;&#039;);
      node.innerHTML = newInnerHTML;
    }
  };
  function performOperationSync(op) {
    op();
  }
  function perform(mutations, callback) {
    const callbackFunction = typeof callback === &#039;function&#039; ? callback : noop$2;
    if (mutations.length === 0) {
      callbackFunction();
    } else {
      let frame = performOperationSync;
      if (config.mutateApproach === MUTATION_APPROACH_ASYNC) {
        frame = WINDOW.requestAnimationFrame || performOperationSync;
      }
      frame(() =&gt; {
        const mutator = getMutator();
        const mark = perf.begin(&#039;mutate&#039;);
        mutations.map(mutator);
        mark();
        callbackFunction();
      });
    }
  }
  let disabled = false;
  function disableObservation() {
    disabled = true;
  }
  function enableObservation() {
    disabled = false;
  }
  let mo = null;
  function observe(options) {
    if (!MUTATION_OBSERVER) {
      return;
    }
    if (!config.observeMutations) {
      return;
    }
    const {
      treeCallback = noop$2,
      nodeCallback = noop$2,
      pseudoElementsCallback = noop$2,
      observeMutationsRoot = DOCUMENT
    } = options;
    mo = new MUTATION_OBSERVER(objects =&gt; {
      if (disabled) return;
      const defaultPrefix = getDefaultUsablePrefix();
      toArray(objects).forEach(mutationRecord =&gt; {
        if (mutationRecord.type === &#039;childList&#039; &amp;&amp; mutationRecord.addedNodes.length &gt; 0 &amp;&amp; !isWatched(mutationRecord.addedNodes[0])) {
          if (config.searchPseudoElements) {
            pseudoElementsCallback(mutationRecord.target);
          }
          treeCallback(mutationRecord.target);
        }
        if (mutationRecord.type === &#039;attributes&#039; &amp;&amp; mutationRecord.target.parentNode &amp;&amp; config.searchPseudoElements) {
          pseudoElementsCallback(mutationRecord.target.parentNode);
        }
        if (mutationRecord.type === &#039;attributes&#039; &amp;&amp; isWatched(mutationRecord.target) &amp;&amp; ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {
          if (mutationRecord.attributeName === &#039;class&#039; &amp;&amp; hasPrefixAndIcon(mutationRecord.target)) {
            const {
              prefix,
              iconName
            } = getCanonicalIcon(classArray(mutationRecord.target));
            mutationRecord.target.setAttribute(DATA_PREFIX, prefix || defaultPrefix);
            if (iconName) mutationRecord.target.setAttribute(DATA_ICON, iconName);
          } else if (hasBeenReplaced(mutationRecord.target)) {
            nodeCallback(mutationRecord.target);
          }
        }
      });
    });
    if (!IS_DOM) return;
    mo.observe(observeMutationsRoot, {
      childList: true,
      attributes: true,
      characterData: true,
      subtree: true
    });
  }
  function disconnect() {
    if (!mo) return;
    mo.disconnect();
  }

  function styleParser (node) {
    const style = node.getAttribute(&#039;style&#039;);
    let val = [];
    if (style) {
      val = style.split(&#039;;&#039;).reduce((acc, style) =&gt; {
        const styles = style.split(&#039;:&#039;);
        const prop = styles[0];
        const value = styles.slice(1);
        if (prop &amp;&amp; value.length &gt; 0) {
          acc[prop] = value.join(&#039;:&#039;).trim();
        }
        return acc;
      }, {});
    }
    return val;
  }

  function classParser (node) {
    const existingPrefix = node.getAttribute(&#039;data-prefix&#039;);
    const existingIconName = node.getAttribute(&#039;data-icon&#039;);
    const innerText = node.innerText !== undefined ? node.innerText.trim() : &#039;&#039;;
    let val = getCanonicalIcon(classArray(node));
    if (!val.prefix) {
      val.prefix = getDefaultUsablePrefix();
    }
    if (existingPrefix &amp;&amp; existingIconName) {
      val.prefix = existingPrefix;
      val.iconName = existingIconName;
    }
    if (val.iconName &amp;&amp; val.prefix) {
      return val;
    }
    if (val.prefix &amp;&amp; innerText.length &gt; 0) {
      val.iconName = byLigature(val.prefix, node.innerText) || byUnicode(val.prefix, toHex(node.innerText));
    }
    if (!val.iconName &amp;&amp; config.autoFetchSvg &amp;&amp; node.firstChild &amp;&amp; node.firstChild.nodeType === Node.TEXT_NODE) {
      val.iconName = node.firstChild.data;
    }
    return val;
  }

  function attributesParser (node) {
    const extraAttributes = toArray(node.attributes).reduce((acc, attr) =&gt; {
      if (acc.name !== &#039;class&#039; &amp;&amp; acc.name !== &#039;style&#039;) {
        acc[attr.name] = attr.value;
      }
      return acc;
    }, {});
    const title = node.getAttribute(&#039;title&#039;);
    const titleId = node.getAttribute(&#039;data-fa-title-id&#039;);
    if (config.autoA11y) {
      if (title) {
        extraAttributes[&#039;aria-labelledby&#039;] = &quot;&quot;.concat(config.replacementClass, &quot;-title-&quot;).concat(titleId || nextUniqueId());
      } else {
        extraAttributes[&#039;aria-hidden&#039;] = &#039;true&#039;;
        extraAttributes[&#039;focusable&#039;] = &#039;false&#039;;
      }
    }
    return extraAttributes;
  }

  function blankMeta() {
    return {
      iconName: null,
      title: null,
      titleId: null,
      prefix: null,
      transform: meaninglessTransform,
      symbol: false,
      mask: {
        iconName: null,
        prefix: null,
        rest: []
      },
      maskId: null,
      extra: {
        classes: [],
        styles: {},
        attributes: {}
      }
    };
  }
  function parseMeta(node) {
    let parser = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : {
      styleParser: true
    };
    const {
      iconName,
      prefix,
      rest: extraClasses
    } = classParser(node);
    const extraAttributes = attributesParser(node);
    const pluginMeta = chainHooks(&#039;parseNodeAttributes&#039;, {}, node);
    let extraStyles = parser.styleParser ? styleParser(node) : [];
    return _objectSpread2({
      iconName,
      title: node.getAttribute(&#039;title&#039;),
      titleId: node.getAttribute(&#039;data-fa-title-id&#039;),
      prefix,
      transform: meaninglessTransform,
      mask: {
        iconName: null,
        prefix: null,
        rest: []
      },
      maskId: null,
      symbol: false,
      extra: {
        classes: extraClasses,
        styles: extraStyles,
        attributes: extraAttributes
      }
    }, pluginMeta);
  }

  const {
    styles: styles$2
  } = namespace;
  function generateMutation(node) {
    const nodeMeta = config.autoReplaceSvg === &#039;nest&#039; ? parseMeta(node, {
      styleParser: false
    }) : parseMeta(node);
    if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {
      return callProvided(&#039;generateLayersText&#039;, node, nodeMeta);
    } else {
      return callProvided(&#039;generateSvgReplacementMutation&#039;, node, nodeMeta);
    }
  }
  function getKnownPrefixes() {
    return [...Ft, ...Ia];
  }
  function onTree(root) {
    let callback = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : null;
    if (!IS_DOM) return Promise.resolve();
    const htmlClassList = DOCUMENT.documentElement.classList;
    const hclAdd = suffix =&gt; htmlClassList.add(&quot;&quot;.concat(HTML_CLASS_I2SVG_BASE_CLASS, &quot;-&quot;).concat(suffix));
    const hclRemove = suffix =&gt; htmlClassList.remove(&quot;&quot;.concat(HTML_CLASS_I2SVG_BASE_CLASS, &quot;-&quot;).concat(suffix));
    const prefixes = config.autoFetchSvg ? getKnownPrefixes() : P.concat(Object.keys(styles$2));
    if (!prefixes.includes(&#039;fa&#039;)) {
      prefixes.push(&#039;fa&#039;);
    }
    const prefixesDomQuery = [&quot;.&quot;.concat(LAYERS_TEXT_CLASSNAME, &quot;:not([&quot;).concat(DATA_FA_I2SVG, &quot;])&quot;)].concat(prefixes.map(p$$1 =&gt; &quot;.&quot;.concat(p$$1, &quot;:not([&quot;).concat(DATA_FA_I2SVG, &quot;])&quot;))).join(&#039;, &#039;);
    if (prefixesDomQuery.length === 0) {
      return Promise.resolve();
    }
    let candidates = [];
    try {
      candidates = toArray(root.querySelectorAll(prefixesDomQuery));
    } catch (e$$1) {
      // noop
    }
    if (candidates.length &gt; 0) {
      hclAdd(&#039;pending&#039;);
      hclRemove(&#039;complete&#039;);
    } else {
      return Promise.resolve();
    }
    const mark = perf.begin(&#039;onTree&#039;);
    const mutations = candidates.reduce((acc, node) =&gt; {
      try {
        const mutation = generateMutation(node);
        if (mutation) {
          acc.push(mutation);
        }
      } catch (e$$1) {
        if (!PRODUCTION) {
          if (e$$1.name === &#039;MissingIcon&#039;) {
            console.error(e$$1);
          }
        }
      }
      return acc;
    }, []);
    return new Promise((resolve, reject) =&gt; {
      Promise.all(mutations).then(resolvedMutations =&gt; {
        perform(resolvedMutations, () =&gt; {
          hclAdd(&#039;active&#039;);
          hclAdd(&#039;complete&#039;);
          hclRemove(&#039;pending&#039;);
          if (typeof callback === &#039;function&#039;) callback();
          mark();
          resolve();
        });
      }).catch(e$$1 =&gt; {
        mark();
        reject(e$$1);
      });
    });
  }
  function onNode(node) {
    let callback = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : null;
    generateMutation(node).then(mutation =&gt; {
      if (mutation) {
        perform([mutation], callback);
      }
    });
  }
  function resolveIcons(next) {
    return function (maybeIconDefinition) {
      let params = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : {};
      const iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
      let {
        mask
      } = params;
      if (mask) {
        mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
      }
      return next(iconDefinition, _objectSpread2(_objectSpread2({}, params), {}, {
        mask
      }));
    };
  }
  const render = function (iconDefinition) {
    let params = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : {};
    const {
      transform = meaninglessTransform,
      symbol = false,
      mask = null,
      maskId = null,
      title = null,
      titleId = null,
      classes = [],
      attributes = {},
      styles = {}
    } = params;
    if (!iconDefinition) return;
    const {
      prefix,
      iconName,
      icon
    } = iconDefinition;
    return domVariants(_objectSpread2({
      type: &#039;icon&#039;
    }, iconDefinition), () =&gt; {
      callHooks(&#039;beforeDOMElementCreation&#039;, {
        iconDefinition,
        params
      });
      if (config.autoA11y) {
        if (title) {
          attributes[&#039;aria-labelledby&#039;] = &quot;&quot;.concat(config.replacementClass, &quot;-title-&quot;).concat(titleId || nextUniqueId());
        } else {
          attributes[&#039;aria-hidden&#039;] = &#039;true&#039;;
          attributes[&#039;focusable&#039;] = &#039;false&#039;;
        }
      }
      return makeInlineSvgAbstract({
        icons: {
          main: asFoundIcon(icon),
          mask: mask ? asFoundIcon(mask.icon) : {
            found: false,
            width: null,
            height: null,
            icon: {}
          }
        },
        prefix,
        iconName,
        transform: _objectSpread2(_objectSpread2({}, meaninglessTransform), transform),
        symbol,
        title,
        maskId,
        titleId,
        extra: {
          attributes,
          styles,
          classes
        }
      });
    });
  };
  var ReplaceElements = {
    mixout() {
      return {
        icon: resolveIcons(render)
      };
    },
    hooks() {
      return {
        mutationObserverCallbacks(accumulator) {
          accumulator.treeCallback = onTree;
          accumulator.nodeCallback = onNode;
          return accumulator;
        }
      };
    },
    provides(providers$$1) {
      providers$$1.i2svg = function (params) {
        const {
          node = DOCUMENT,
          callback = () =&gt; {}
        } = params;
        return onTree(node, callback);
      };
      providers$$1.generateSvgReplacementMutation = function (node, nodeMeta) {
        const {
          iconName,
          title,
          titleId,
          prefix,
          transform,
          symbol,
          mask,
          maskId,
          extra
        } = nodeMeta;
        return new Promise((resolve, reject) =&gt; {
          Promise.all([findIcon(iconName, prefix), mask.iconName ? findIcon(mask.iconName, mask.prefix) : Promise.resolve({
            found: false,
            width: 512,
            height: 512,
            icon: {}
          })]).then(_ref =&gt; {
            let [main, mask] = _ref;
            resolve([node, makeInlineSvgAbstract({
              icons: {
                main,
                mask
              },
              prefix,
              iconName,
              transform,
              symbol,
              maskId,
              title,
              titleId,
              extra,
              watchable: true
            })]);
          }).catch(reject);
        });
      };
      providers$$1.generateAbstractIcon = function (_ref2) {
        let {
          children,
          attributes,
          main,
          transform,
          styles
        } = _ref2;
        const styleString = joinStyles(styles);
        if (styleString.length &gt; 0) {
          attributes[&#039;style&#039;] = styleString;
        }
        let nextChild;
        if (transformIsMeaningful(transform)) {
          nextChild = callProvided(&#039;generateAbstractTransformGrouping&#039;, {
            main,
            transform,
            containerWidth: main.width,
            iconWidth: main.width
          });
        }
        children.push(nextChild || main.icon);
        return {
          children,
          attributes
        };
      };
    }
  };

  var Layers = {
    mixout() {
      return {
        layer(assembler) {
          let params = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : {};
          const {
            classes = []
          } = params;
          return domVariants({
            type: &#039;layer&#039;
          }, () =&gt; {
            callHooks(&#039;beforeDOMElementCreation&#039;, {
              assembler,
              params
            });
            let children = [];
            assembler(args =&gt; {
              Array.isArray(args) ? args.map(a =&gt; {
                children = children.concat(a.abstract);
              }) : children = children.concat(args.abstract);
            });
            return [{
              tag: &#039;span&#039;,
              attributes: {
                class: [&quot;&quot;.concat(config.cssPrefix, &quot;-layers&quot;), ...classes].join(&#039; &#039;)
              },
              children
            }];
          });
        }
      };
    }
  };

  var LayersCounter = {
    mixout() {
      return {
        counter(content) {
          let params = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : {};
          const {
            title = null,
            classes = [],
            attributes = {},
            styles = {}
          } = params;
          return domVariants({
            type: &#039;counter&#039;,
            content
          }, () =&gt; {
            callHooks(&#039;beforeDOMElementCreation&#039;, {
              content,
              params
            });
            return makeLayersCounterAbstract({
              content: content.toString(),
              title,
              extra: {
                attributes,
                styles,
                classes: [&quot;&quot;.concat(config.cssPrefix, &quot;-layers-counter&quot;), ...classes]
              }
            });
          });
        }
      };
    }
  };

  var LayersText = {
    mixout() {
      return {
        text(content) {
          let params = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : {};
          const {
            transform = meaninglessTransform,
            title = null,
            classes = [],
            attributes = {},
            styles = {}
          } = params;
          return domVariants({
            type: &#039;text&#039;,
            content
          }, () =&gt; {
            callHooks(&#039;beforeDOMElementCreation&#039;, {
              content,
              params
            });
            return makeLayersTextAbstract({
              content,
              transform: _objectSpread2(_objectSpread2({}, meaninglessTransform), transform),
              title,
              extra: {
                attributes,
                styles,
                classes: [&quot;&quot;.concat(config.cssPrefix, &quot;-layers-text&quot;), ...classes]
              }
            });
          });
        }
      };
    },
    provides(providers$$1) {
      providers$$1.generateLayersText = function (node, nodeMeta) {
        const {
          title,
          transform,
          extra
        } = nodeMeta;
        let width = null;
        let height = null;
        if (IS_IE) {
          const computedFontSize = parseInt(getComputedStyle(node).fontSize, 10);
          const boundingClientRect = node.getBoundingClientRect();
          width = boundingClientRect.width / computedFontSize;
          height = boundingClientRect.height / computedFontSize;
        }
        if (config.autoA11y &amp;&amp; !title) {
          extra.attributes[&#039;aria-hidden&#039;] = &#039;true&#039;;
        }
        return Promise.resolve([node, makeLayersTextAbstract({
          content: node.innerHTML,
          width,
          height,
          transform,
          title,
          extra,
          watchable: true
        })]);
      };
    }
  };

  const CLEAN_CONTENT_PATTERN = new RegExp(&#039;\u{22}&#039;, &#039;ug&#039;);
  const SECONDARY_UNICODE_RANGE = [1105920, 1112319];
  const _FONT_FAMILY_WEIGHT_TO_PREFIX = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, {
    FontAwesome: {
      normal: &#039;fas&#039;,
      400: &#039;fas&#039;
    }
  }), lt), wa), Yt);
  const FONT_FAMILY_WEIGHT_TO_PREFIX = Object.keys(_FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, key) =&gt; {
    acc[key.toLowerCase()] = _FONT_FAMILY_WEIGHT_TO_PREFIX[key];
    return acc;
  }, {});
  const FONT_FAMILY_WEIGHT_FALLBACK = Object.keys(FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, fontFamily) =&gt; {
    const weights = FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamily];
    acc[fontFamily] = weights[900] || [...Object.entries(weights)][0][1];
    return acc;
  }, {});
  function hexValueFromContent(content) {
    const cleaned = content.replace(CLEAN_CONTENT_PATTERN, &#039;&#039;);
    const codePoint = codePointAt(cleaned, 0);
    const isPrependTen = codePoint &gt;= SECONDARY_UNICODE_RANGE[0] &amp;&amp; codePoint &lt;= SECONDARY_UNICODE_RANGE[1];
    const isDoubled = cleaned.length === 2 ? cleaned[0] === cleaned[1] : false;
    return {
      value: isDoubled ? toHex(cleaned[0]) : toHex(cleaned),
      isSecondary: isPrependTen || isDoubled
    };
  }
  function getPrefix(fontFamily, fontWeight) {
    const fontFamilySanitized = fontFamily.replace(/^[&#039;&quot;]|[&#039;&quot;]$/g, &#039;&#039;).toLowerCase();
    const fontWeightInteger = parseInt(fontWeight);
    const fontWeightSanitized = isNaN(fontWeightInteger) ? &#039;normal&#039; : fontWeightInteger;
    return (FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamilySanitized] || {})[fontWeightSanitized] || FONT_FAMILY_WEIGHT_FALLBACK[fontFamilySanitized];
  }
  function replaceForPosition(node, position) {
    const pendingAttribute = &quot;&quot;.concat(DATA_FA_PSEUDO_ELEMENT_PENDING).concat(position.replace(&#039;:&#039;, &#039;-&#039;));
    return new Promise((resolve, reject) =&gt; {
      if (node.getAttribute(pendingAttribute) !== null) {
        // This node is already being processed
        return resolve();
      }
      const children = toArray(node.children);
      const alreadyProcessedPseudoElement = children.filter(c$$1 =&gt; c$$1.getAttribute(DATA_FA_PSEUDO_ELEMENT) === position)[0];
      const styles = WINDOW.getComputedStyle(node, position);
      const fontFamily = styles.getPropertyValue(&#039;font-family&#039;);
      const fontFamilyMatch = fontFamily.match(FONT_FAMILY_PATTERN);
      const fontWeight = styles.getPropertyValue(&#039;font-weight&#039;);
      const content = styles.getPropertyValue(&#039;content&#039;);
      if (alreadyProcessedPseudoElement &amp;&amp; !fontFamilyMatch) {
        // If we&#039;ve already processed it but the current computed style does not result in a font-family,
        // that probably means that a class name that was previously present to make the icon has been
        // removed. So we now should delete the icon.
        node.removeChild(alreadyProcessedPseudoElement);
        return resolve();
      } else if (fontFamilyMatch &amp;&amp; content !== &#039;none&#039; &amp;&amp; content !== &#039;&#039;) {
        const content = styles.getPropertyValue(&#039;content&#039;);
        let prefix = getPrefix(fontFamily, fontWeight);
        const {
          value: hexValue,
          isSecondary
        } = hexValueFromContent(content);
        const isV4 = fontFamilyMatch[0].startsWith(&#039;FontAwesome&#039;);
        let iconName = byUnicode(prefix, hexValue);
        let iconIdentifier = iconName;
        if (isV4) {
          const iconName4 = byOldUnicode(hexValue);
          if (iconName4.iconName &amp;&amp; iconName4.prefix) {
            iconName = iconName4.iconName;
            prefix = iconName4.prefix;
          }
        }

        // Only convert the pseudo element in this ::before/::after position into an icon if we haven&#039;t
        // already done so with the same prefix and iconName
        if (iconName &amp;&amp; !isSecondary &amp;&amp; (!alreadyProcessedPseudoElement || alreadyProcessedPseudoElement.getAttribute(DATA_PREFIX) !== prefix || alreadyProcessedPseudoElement.getAttribute(DATA_ICON) !== iconIdentifier)) {
          node.setAttribute(pendingAttribute, iconIdentifier);
          if (alreadyProcessedPseudoElement) {
            // Delete the old one, since we&#039;re replacing it with a new one
            node.removeChild(alreadyProcessedPseudoElement);
          }
          const meta = blankMeta();
          const {
            extra
          } = meta;
          extra.attributes[DATA_FA_PSEUDO_ELEMENT] = position;
          findIcon(iconName, prefix).then(main =&gt; {
            const abstract = makeInlineSvgAbstract(_objectSpread2(_objectSpread2({}, meta), {}, {
              icons: {
                main,
                mask: emptyCanonicalIcon()
              },
              prefix,
              iconName: iconIdentifier,
              extra,
              watchable: true
            }));
            const element = DOCUMENT.createElementNS(&#039;http://www.w3.org/2000/svg&#039;, &#039;svg&#039;);
            if (position === &#039;::before&#039;) {
              node.insertBefore(element, node.firstChild);
            } else {
              node.appendChild(element);
            }
            element.outerHTML = abstract.map(a$$1 =&gt; toHtml(a$$1)).join(&#039;\n&#039;);
            node.removeAttribute(pendingAttribute);
            resolve();
          }).catch(reject);
        } else {
          resolve();
        }
      } else {
        resolve();
      }
    });
  }
  function replace(node) {
    return Promise.all([replaceForPosition(node, &#039;::before&#039;), replaceForPosition(node, &#039;::after&#039;)]);
  }
  function processable(node) {
    return node.parentNode !== document.head &amp;&amp; !~TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS.indexOf(node.tagName.toUpperCase()) &amp;&amp; !node.getAttribute(DATA_FA_PSEUDO_ELEMENT) &amp;&amp; (!node.parentNode || node.parentNode.tagName !== &#039;svg&#039;);
  }
  function searchPseudoElements(root) {
    if (!IS_DOM) return;
    return new Promise((resolve, reject) =&gt; {
      const operations = toArray(root.querySelectorAll(&#039;*&#039;)).filter(processable).map(replace);
      const end = perf.begin(&#039;searchPseudoElements&#039;);
      disableObservation();
      Promise.all(operations).then(() =&gt; {
        end();
        enableObservation();
        resolve();
      }).catch(() =&gt; {
        end();
        enableObservation();
        reject();
      });
    });
  }
  var PseudoElements = {
    hooks() {
      return {
        mutationObserverCallbacks(accumulator) {
          accumulator.pseudoElementsCallback = searchPseudoElements;
          return accumulator;
        }
      };
    },
    provides(providers) {
      providers.pseudoElements2svg = function (params) {
        const {
          node = DOCUMENT
        } = params;
        if (config.searchPseudoElements) {
          searchPseudoElements(node);
        }
      };
    }
  };

  let _unwatched = false;
  var MutationObserver$1 = {
    mixout() {
      return {
        dom: {
          unwatch() {
            disableObservation();
            _unwatched = true;
          }
        }
      };
    },
    hooks() {
      return {
        bootstrap() {
          observe(chainHooks(&#039;mutationObserverCallbacks&#039;, {}));
        },
        noAuto() {
          disconnect();
        },
        watch(params) {
          const {
            observeMutationsRoot
          } = params;
          if (_unwatched) {
            enableObservation();
          } else {
            observe(chainHooks(&#039;mutationObserverCallbacks&#039;, {
              observeMutationsRoot
            }));
          }
        }
      };
    }
  };

  const parseTransformString = transformString =&gt; {
    let transform = {
      size: 16,
      x: 0,
      y: 0,
      flipX: false,
      flipY: false,
      rotate: 0
    };
    return transformString.toLowerCase().split(&#039; &#039;).reduce((acc, n) =&gt; {
      const parts = n.toLowerCase().split(&#039;-&#039;);
      const first = parts[0];
      let rest = parts.slice(1).join(&#039;-&#039;);
      if (first &amp;&amp; rest === &#039;h&#039;) {
        acc.flipX = true;
        return acc;
      }
      if (first &amp;&amp; rest === &#039;v&#039;) {
        acc.flipY = true;
        return acc;
      }
      rest = parseFloat(rest);
      if (isNaN(rest)) {
        return acc;
      }
      switch (first) {
        case &#039;grow&#039;:
          acc.size = acc.size + rest;
          break;
        case &#039;shrink&#039;:
          acc.size = acc.size - rest;
          break;
        case &#039;left&#039;:
          acc.x = acc.x - rest;
          break;
        case &#039;right&#039;:
          acc.x = acc.x + rest;
          break;
        case &#039;up&#039;:
          acc.y = acc.y - rest;
          break;
        case &#039;down&#039;:
          acc.y = acc.y + rest;
          break;
        case &#039;rotate&#039;:
          acc.rotate = acc.rotate + rest;
          break;
      }
      return acc;
    }, transform);
  };
  var PowerTransforms = {
    mixout() {
      return {
        parse: {
          transform: transformString =&gt; {
            return parseTransformString(transformString);
          }
        }
      };
    },
    hooks() {
      return {
        parseNodeAttributes(accumulator, node) {
          const transformString = node.getAttribute(&#039;data-fa-transform&#039;);
          if (transformString) {
            accumulator.transform = parseTransformString(transformString);
          }
          return accumulator;
        }
      };
    },
    provides(providers) {
      providers.generateAbstractTransformGrouping = function (_ref) {
        let {
          main,
          transform,
          containerWidth,
          iconWidth
        } = _ref;
        const outer = {
          transform: &quot;translate(&quot;.concat(containerWidth / 2, &quot; 256)&quot;)
        };
        const innerTranslate = &quot;translate(&quot;.concat(transform.x * 32, &quot;, &quot;).concat(transform.y * 32, &quot;) &quot;);
        const innerScale = &quot;scale(&quot;.concat(transform.size / 16 * (transform.flipX ? -1 : 1), &quot;, &quot;).concat(transform.size / 16 * (transform.flipY ? -1 : 1), &quot;) &quot;);
        const innerRotate = &quot;rotate(&quot;.concat(transform.rotate, &quot; 0 0)&quot;);
        const inner = {
          transform: &quot;&quot;.concat(innerTranslate, &quot; &quot;).concat(innerScale, &quot; &quot;).concat(innerRotate)
        };
        const path = {
          transform: &quot;translate(&quot;.concat(iconWidth / 2 * -1, &quot; -256)&quot;)
        };
        const operations = {
          outer,
          inner,
          path
        };
        return {
          tag: &#039;g&#039;,
          attributes: _objectSpread2({}, operations.outer),
          children: [{
            tag: &#039;g&#039;,
            attributes: _objectSpread2({}, operations.inner),
            children: [{
              tag: main.icon.tag,
              children: main.icon.children,
              attributes: _objectSpread2(_objectSpread2({}, main.icon.attributes), operations.path)
            }]
          }]
        };
      };
    }
  };

  const ALL_SPACE = {
    x: 0,
    y: 0,
    width: &#039;100%&#039;,
    height: &#039;100%&#039;
  };
  function fillBlack(abstract) {
    let force = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : true;
    if (abstract.attributes &amp;&amp; (abstract.attributes.fill || force)) {
      abstract.attributes.fill = &#039;black&#039;;
    }
    return abstract;
  }
  function deGroup(abstract) {
    if (abstract.tag === &#039;g&#039;) {
      return abstract.children;
    } else {
      return [abstract];
    }
  }
  var Masks = {
    hooks() {
      return {
        parseNodeAttributes(accumulator, node) {
          const maskData = node.getAttribute(&#039;data-fa-mask&#039;);
          const mask = !maskData ? emptyCanonicalIcon() : getCanonicalIcon(maskData.split(&#039; &#039;).map(i =&gt; i.trim()));
          if (!mask.prefix) {
            mask.prefix = getDefaultUsablePrefix();
          }
          accumulator.mask = mask;
          accumulator.maskId = node.getAttribute(&#039;data-fa-mask-id&#039;);
          return accumulator;
        }
      };
    },
    provides(providers) {
      providers.generateAbstractMask = function (_ref) {
        let {
          children,
          attributes,
          main,
          mask,
          maskId: explicitMaskId,
          transform
        } = _ref;
        const {
          width: mainWidth,
          icon: mainPath
        } = main;
        const {
          width: maskWidth,
          icon: maskPath
        } = mask;
        const trans = transformForSvg({
          transform,
          containerWidth: maskWidth,
          iconWidth: mainWidth
        });
        const maskRect = {
          tag: &#039;rect&#039;,
          attributes: _objectSpread2(_objectSpread2({}, ALL_SPACE), {}, {
            fill: &#039;white&#039;
          })
        };
        const maskInnerGroupChildrenMixin = mainPath.children ? {
          children: mainPath.children.map(fillBlack)
        } : {};
        const maskInnerGroup = {
          tag: &#039;g&#039;,
          attributes: _objectSpread2({}, trans.inner),
          children: [fillBlack(_objectSpread2({
            tag: mainPath.tag,
            attributes: _objectSpread2(_objectSpread2({}, mainPath.attributes), trans.path)
          }, maskInnerGroupChildrenMixin))]
        };
        const maskOuterGroup = {
          tag: &#039;g&#039;,
          attributes: _objectSpread2({}, trans.outer),
          children: [maskInnerGroup]
        };
        const maskId = &quot;mask-&quot;.concat(explicitMaskId || nextUniqueId());
        const clipId = &quot;clip-&quot;.concat(explicitMaskId || nextUniqueId());
        const maskTag = {
          tag: &#039;mask&#039;,
          attributes: _objectSpread2(_objectSpread2({}, ALL_SPACE), {}, {
            id: maskId,
            maskUnits: &#039;userSpaceOnUse&#039;,
            maskContentUnits: &#039;userSpaceOnUse&#039;
          }),
          children: [maskRect, maskOuterGroup]
        };
        const defs = {
          tag: &#039;defs&#039;,
          children: [{
            tag: &#039;clipPath&#039;,
            attributes: {
              id: clipId
            },
            children: deGroup(maskPath)
          }, maskTag]
        };
        children.push(defs, {
          tag: &#039;rect&#039;,
          attributes: _objectSpread2({
            fill: &#039;currentColor&#039;,
            &#039;clip-path&#039;: &quot;url(#&quot;.concat(clipId, &quot;)&quot;),
            mask: &quot;url(#&quot;.concat(maskId, &quot;)&quot;)
          }, ALL_SPACE)
        });
        return {
          children,
          attributes
        };
      };
    }
  };

  var MissingIconIndicator = {
    provides(providers) {
      let reduceMotion = false;
      if (WINDOW.matchMedia) {
        reduceMotion = WINDOW.matchMedia(&#039;(prefers-reduced-motion: reduce)&#039;).matches;
      }
      providers.missingIconAbstract = function () {
        const gChildren = [];
        const FILL = {
          fill: &#039;currentColor&#039;
        };
        const ANIMATION_BASE = {
          attributeType: &#039;XML&#039;,
          repeatCount: &#039;indefinite&#039;,
          dur: &#039;2s&#039;
        };

        // Ring
        gChildren.push({
          tag: &#039;path&#039;,
          attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
            d: &#039;M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z&#039;
          })
        });
        const OPACITY_ANIMATE = _objectSpread2(_objectSpread2({}, ANIMATION_BASE), {}, {
          attributeName: &#039;opacity&#039;
        });
        const dot = {
          tag: &#039;circle&#039;,
          attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
            cx: &#039;256&#039;,
            cy: &#039;364&#039;,
            r: &#039;28&#039;
          }),
          children: []
        };
        if (!reduceMotion) {
          dot.children.push({
            tag: &#039;animate&#039;,
            attributes: _objectSpread2(_objectSpread2({}, ANIMATION_BASE), {}, {
              attributeName: &#039;r&#039;,
              values: &#039;28;14;28;28;14;28;&#039;
            })
          }, {
            tag: &#039;animate&#039;,
            attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
              values: &#039;1;0;1;1;0;1;&#039;
            })
          });
        }
        gChildren.push(dot);
        gChildren.push({
          tag: &#039;path&#039;,
          attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
            opacity: &#039;1&#039;,
            d: &#039;M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z&#039;
          }),
          children: reduceMotion ? [] : [{
            tag: &#039;animate&#039;,
            attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
              values: &#039;1;0;0;0;0;1;&#039;
            })
          }]
        });
        if (!reduceMotion) {
          // Exclamation
          gChildren.push({
            tag: &#039;path&#039;,
            attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
              opacity: &#039;0&#039;,
              d: &#039;M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z&#039;
            }),
            children: [{
              tag: &#039;animate&#039;,
              attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
                values: &#039;0;0;1;1;0;0;&#039;
              })
            }]
          });
        }
        return {
          tag: &#039;g&#039;,
          attributes: {
            &#039;class&#039;: &#039;missing&#039;
          },
          children: gChildren
        };
      };
    }
  };

  var SvgSymbols = {
    hooks() {
      return {
        parseNodeAttributes(accumulator, node) {
          const symbolData = node.getAttribute(&#039;data-fa-symbol&#039;);
          const symbol = symbolData === null ? false : symbolData === &#039;&#039; ? true : symbolData;
          accumulator[&#039;symbol&#039;] = symbol;
          return accumulator;
        }
      };
    }
  };

  var plugins = [InjectCSS, ReplaceElements, Layers, LayersCounter, LayersText, PseudoElements, MutationObserver$1, PowerTransforms, Masks, MissingIconIndicator, SvgSymbols];

  registerPlugins(plugins, {
    mixoutsTo: api
  });
  bunker(bootstrap);

}());
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
